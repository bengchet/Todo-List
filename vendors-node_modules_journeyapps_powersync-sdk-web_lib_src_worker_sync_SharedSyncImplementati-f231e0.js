/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/AbstractPowerSyncDatabase.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/client/AbstractPowerSyncDatabase.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractPowerSyncDatabase: () => (/* binding */ AbstractPowerSyncDatabase),
/* harmony export */   DEFAULT_LOCK_TIMEOUT_MS: () => (/* binding */ DEFAULT_LOCK_TIMEOUT_MS),
/* harmony export */   DEFAULT_POWERSYNC_CLOSE_OPTIONS: () => (/* binding */ DEFAULT_POWERSYNC_CLOSE_OPTIONS),
/* harmony export */   DEFAULT_POWERSYNC_DB_OPTIONS: () => (/* binding */ DEFAULT_POWERSYNC_DB_OPTIONS),
/* harmony export */   DEFAULT_WATCH_THROTTLE_MS: () => (/* binding */ DEFAULT_WATCH_THROTTLE_MS)
/* harmony export */ });
/* harmony import */ var C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncIterator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncIterator.js */ "./node_modules/@babel/runtime/helpers/esm/asyncIterator.js");
/* harmony import */ var async_mutex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! async-mutex */ "./node_modules/async-mutex/index.mjs");
/* harmony import */ var event_iterator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! event-iterator */ "./node_modules/event-iterator/lib/dom.js");
/* harmony import */ var js_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! js-logger */ "./node_modules/js-logger/src/logger.js");
/* harmony import */ var js_logger__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(js_logger__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/throttle */ "./node_modules/lodash/throttle.js");
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _db_DBAdapter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../db/DBAdapter */ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/DBAdapter.js");
/* harmony import */ var _db_crud_UploadQueueStatus__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../db/crud/UploadQueueStatus */ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/crud/UploadQueueStatus.js");
/* harmony import */ var _utils_BaseObserver__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/BaseObserver */ "./node_modules/@journeyapps/powersync-sdk-common/lib/utils/BaseObserver.js");
/* harmony import */ var _utils_mutex__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/mutex */ "./node_modules/@journeyapps/powersync-sdk-common/lib/utils/mutex.js");
/* harmony import */ var _utils_strings__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/strings */ "./node_modules/@journeyapps/powersync-sdk-common/lib/utils/strings.js");
/* harmony import */ var _sync_bucket_BucketStorageAdapter__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sync/bucket/BucketStorageAdapter */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/BucketStorageAdapter.js");
/* harmony import */ var _sync_bucket_CrudBatch__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./sync/bucket/CrudBatch */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/CrudBatch.js");
/* harmony import */ var _sync_bucket_CrudEntry__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./sync/bucket/CrudEntry */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/CrudEntry.js");
/* harmony import */ var _sync_bucket_CrudTransaction__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./sync/bucket/CrudTransaction */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/CrudTransaction.js");
/* harmony import */ var _sync_stream_AbstractStreamingSyncImplementation__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./sync/stream/AbstractStreamingSyncImplementation */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/stream/AbstractStreamingSyncImplementation.js");
















const POWERSYNC_TABLE_MATCH = /(^ps_data__|^ps_data_local__)/;
const DEFAULT_DISCONNECT_CLEAR_OPTIONS = {
  clearLocal: true
};
const DEFAULT_POWERSYNC_CLOSE_OPTIONS = {
  disconnect: true
};
const DEFAULT_WATCH_THROTTLE_MS = 30;
const DEFAULT_POWERSYNC_DB_OPTIONS = {
  retryDelay: 5000,
  logger: js_logger__WEBPACK_IMPORTED_MODULE_4___default().get('PowerSyncDatabase'),
  crudUploadThrottleMs: _sync_stream_AbstractStreamingSyncImplementation__WEBPACK_IMPORTED_MODULE_15__.DEFAULT_CRUD_UPLOAD_THROTTLE_MS
};
/**
 * Requesting nested or recursive locks can block the application in some circumstances.
 * This default lock timeout will act as a failsafe to throw an error if a lock cannot
 * be obtained.
 */
const DEFAULT_LOCK_TIMEOUT_MS = 120_000; // 2 mins
class AbstractPowerSyncDatabase extends _utils_BaseObserver__WEBPACK_IMPORTED_MODULE_8__.BaseObserver {
  options;
  /**
   * Transactions should be queued in the DBAdapter, but we also want to prevent
   * calls to `.execute` while an async transaction is running.
   */
  static transactionMutex = new async_mutex__WEBPACK_IMPORTED_MODULE_2__.Mutex();
  /**
   * Returns true if the connection is closed.
   */
  closed;
  ready;
  /**
   * Current connection status.
   */
  currentStatus;
  syncStreamImplementation;
  sdkVersion;
  bucketStorageAdapter;
  syncStatusListenerDisposer;
  _isReadyPromise;
  _schema;
  constructor(options) {
    super();
    this.options = options;
    this.bucketStorageAdapter = this.generateBucketStorageAdapter();
    this.closed = false;
    this.currentStatus = undefined;
    this.options = {
      ...DEFAULT_POWERSYNC_DB_OPTIONS,
      ...options
    };
    this._schema = options.schema;
    this.ready = false;
    this.sdkVersion = '';
    // Start async init
    this._isReadyPromise = this.initialize();
  }
  /**
   * Schema used for the local database.
   */
  get schema() {
    return this._schema;
  }
  /**
   * The underlying database.
   *
   * For the most part, behavior is the same whether querying on the underlying database, or on {@link AbstractPowerSyncDatabase}.
   */
  get database() {
    return this.options.database;
  }
  /**
   * Whether a connection to the PowerSync service is currently open.
   */
  get connected() {
    return this.currentStatus?.connected || false;
  }
  /**
   * @returns A promise which will resolve once initialization is completed.
   */
  waitForReady() {
    var _this = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (_this.ready) {
        return;
      }
      yield _this._isReadyPromise;
    })();
  }
  /**
   * Entry point for executing initialization logic.
   * This is to be automatically executed in the constructor.
   */
  initialize() {
    var _this2 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _this2._initialize();
      yield _this2.bucketStorageAdapter.init();
      const version = yield _this2.options.database.execute('SELECT powersync_rs_version()');
      _this2.sdkVersion = version.rows?.item(0)['powersync_rs_version()'] ?? '';
      yield _this2.updateSchema(_this2.options.schema);
      _this2.ready = true;
      _this2.iterateListeners(cb => cb.initialized?.());
    })();
  }
  /**
   * Replace the schema with a new version. This is for advanced use cases - typically the schema should just be specified once in the constructor.
   *
   * Cannot be used while connected - this should only be called before {@link AbstractPowerSyncDatabase.connect}.
   */
  updateSchema(schema) {
    var _this3 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (_this3.syncStreamImplementation) {
        throw new Error('Cannot update schema while connected');
      }
      /**
       * TODO
       * Validations only show a warning for now.
       * The next major release should throw an exception.
       */
      try {
        schema.validate();
      } catch (ex) {
        _this3.options.logger?.warn('Schema validation failed. Unexpected behaviour could occur', ex);
      }
      _this3._schema = schema;
      yield _this3.database.execute('SELECT powersync_replace_schema(?)', [JSON.stringify(_this3.schema.toJSON())]);
    })();
  }
  /**
   * Wait for initialization to complete.
   * While initializing is automatic, this helps to catch and report initialization errors.
   */
  init() {
    var _this4 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      return _this4.waitForReady();
    })();
  }
  /**
   * Connects to stream of events from the PowerSync instance.
   */
  connect(connector) {
    var _this5 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _this5.waitForReady();
      // close connection if one is open
      yield _this5.disconnect();
      if (_this5.closed) {
        throw new Error('Cannot connect using a closed client');
      }
      _this5.syncStreamImplementation = _this5.generateSyncStreamImplementation(connector);
      _this5.syncStatusListenerDisposer = _this5.syncStreamImplementation.registerListener({
        statusChanged: status => {
          _this5.currentStatus = status;
          _this5.iterateListeners(cb => cb.statusChanged?.(status));
        }
      });
      yield _this5.syncStreamImplementation.waitForReady();
      _this5.syncStreamImplementation.triggerCrudUpload();
      _this5.syncStreamImplementation.connect();
    })();
  }
  /**
   * Close the sync connection.
   *
   * Use {@link connect} to connect again.
   */
  disconnect() {
    var _this6 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _this6.syncStreamImplementation?.disconnect();
      _this6.syncStatusListenerDisposer?.();
      yield _this6.syncStreamImplementation?.dispose();
      _this6.syncStreamImplementation = undefined;
    })();
  }
  /**
   *  Disconnect and clear the database.
   *  Use this when logging out.
   *  The database can still be queried after this is called, but the tables
   *  would be empty.
   *
   * To preserve data in local-only tables, set clearLocal to false.
   */
  disconnectAndClear(options = DEFAULT_DISCONNECT_CLEAR_OPTIONS) {
    var _this7 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _this7.disconnect();
      yield _this7.waitForReady();
      const {
        clearLocal
      } = options;
      // TODO DB name, verify this is necessary with extension
      yield _this7.database.writeTransaction( /*#__PURE__*/function () {
        var _ref = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (tx) {
          yield tx.execute(`DELETE FROM ${_sync_bucket_BucketStorageAdapter__WEBPACK_IMPORTED_MODULE_11__.PSInternalTable.OPLOG}`);
          yield tx.execute(`DELETE FROM ${_sync_bucket_BucketStorageAdapter__WEBPACK_IMPORTED_MODULE_11__.PSInternalTable.CRUD}`);
          yield tx.execute(`DELETE FROM ${_sync_bucket_BucketStorageAdapter__WEBPACK_IMPORTED_MODULE_11__.PSInternalTable.BUCKETS}`);
          const tableGlob = clearLocal ? 'ps_data_*' : 'ps_data__*';
          const existingTableRows = yield tx.execute(`
      SELECT name FROM sqlite_master WHERE type='table' AND name GLOB ?
      `, [tableGlob]);
          if (!existingTableRows.rows?.length) {
            return;
          }
          for (const row of existingTableRows.rows._array) {
            yield tx.execute(`DELETE FROM ${(0,_utils_strings__WEBPACK_IMPORTED_MODULE_10__.quoteIdentifier)(row.name)} WHERE 1`);
          }
        });
        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());
    })();
  }
  /**
   * Close the database, releasing resources.
   *
   * Also disconnects any active connection.
   *
   * Once close is called, this connection cannot be used again - a new one
   * must be constructed.
   */
  close(options = DEFAULT_POWERSYNC_CLOSE_OPTIONS) {
    var _this8 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _this8.waitForReady();
      const {
        disconnect
      } = options;
      if (disconnect) {
        yield _this8.disconnect();
      }
      yield _this8.syncStreamImplementation?.dispose();
      _this8.database.close();
      _this8.closed = true;
    })();
  }
  /**
   * Get upload queue size estimate and count.
   */
  getUploadQueueStats(includeSize) {
    var _this9 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      return _this9.readTransaction( /*#__PURE__*/function () {
        var _ref2 = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (tx) {
          if (includeSize) {
            const result = yield tx.execute(`SELECT SUM(cast(data as blob) + 20) as size, count(*) as count FROM ${_sync_bucket_BucketStorageAdapter__WEBPACK_IMPORTED_MODULE_11__.PSInternalTable.CRUD}`);
            const row = result.rows.item(0);
            return new _db_crud_UploadQueueStatus__WEBPACK_IMPORTED_MODULE_7__.UploadQueueStats(row?.count ?? 0, row?.size ?? 0);
          } else {
            const result = yield tx.execute(`SELECT count(*) as count FROM ${_sync_bucket_BucketStorageAdapter__WEBPACK_IMPORTED_MODULE_11__.PSInternalTable.CRUD}`);
            const row = result.rows.item(0);
            return new _db_crud_UploadQueueStatus__WEBPACK_IMPORTED_MODULE_7__.UploadQueueStats(row?.count ?? 0);
          }
        });
        return function (_x2) {
          return _ref2.apply(this, arguments);
        };
      }());
    })();
  }
  /**
   * Get a batch of crud data to upload.
   *
   * Returns null if there is no data to upload.
   *
   * Use this from the {@link PowerSyncBackendConnector.uploadData} callback.
   *
   * Once the data have been successfully uploaded, call {@link CrudBatch.complete} before
   * requesting the next batch.
   *
   * Use {@link limit} to specify the maximum number of updates to return in a single
   * batch.
   *
   * This method does include transaction ids in the result, but does not group
   * data by transaction. One batch may contain data from multiple transactions,
   * and a single transaction may be split over multiple batches.
   */
  getCrudBatch(limit) {
    var _this10 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const result = yield _this10.getAll(`SELECT id, tx_id, data FROM ${_sync_bucket_BucketStorageAdapter__WEBPACK_IMPORTED_MODULE_11__.PSInternalTable.CRUD} ORDER BY id ASC LIMIT ?`, [limit + 1]);
      const all = result.map(row => _sync_bucket_CrudEntry__WEBPACK_IMPORTED_MODULE_13__.CrudEntry.fromRow(row)) ?? [];
      let haveMore = false;
      if (all.length > limit) {
        all.pop();
        haveMore = true;
      }
      if (all.length == 0) {
        return null;
      }
      const last = all[all.length - 1];
      return new _sync_bucket_CrudBatch__WEBPACK_IMPORTED_MODULE_12__.CrudBatch(all, haveMore, /*#__PURE__*/function () {
        var _ref3 = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (writeCheckpoint) {
          return _this10.handleCrudCheckpoint(last.clientId, writeCheckpoint);
        });
        return function (_x3) {
          return _ref3.apply(this, arguments);
        };
      }());
    })();
  }
  /**
   * Get the next recorded transaction to upload.
   *
   * Returns null if there is no data to upload.
   *
   * Use this from the {@link PowerSyncBackendConnector.uploadData} callback.
   *
   * Once the data have been successfully uploaded, call {@link CrudTransaction.complete} before
   * requesting the next transaction.
   *
   * Unlike {@link getCrudBatch}, this only returns data from a single transaction at a time.
   * All data for the transaction is loaded into memory.
   */
  getNextCrudTransaction() {
    var _this11 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      return yield _this11.readTransaction( /*#__PURE__*/function () {
        var _ref4 = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (tx) {
          const first = yield tx.getOptional(`SELECT id, tx_id, data FROM ${_sync_bucket_BucketStorageAdapter__WEBPACK_IMPORTED_MODULE_11__.PSInternalTable.CRUD} ORDER BY id ASC LIMIT 1`);
          if (!first) {
            return null;
          }
          const txId = first.tx_id;
          let all;
          if (!txId) {
            all = [_sync_bucket_CrudEntry__WEBPACK_IMPORTED_MODULE_13__.CrudEntry.fromRow(first)];
          } else {
            const result = yield tx.getAll(`SELECT id, tx_id, data FROM ${_sync_bucket_BucketStorageAdapter__WEBPACK_IMPORTED_MODULE_11__.PSInternalTable.CRUD} WHERE tx_id = ? ORDER BY id ASC`, [txId]);
            all = result.map(row => _sync_bucket_CrudEntry__WEBPACK_IMPORTED_MODULE_13__.CrudEntry.fromRow(row));
          }
          const last = all[all.length - 1];
          return new _sync_bucket_CrudTransaction__WEBPACK_IMPORTED_MODULE_14__.CrudTransaction(all, /*#__PURE__*/function () {
            var _ref5 = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (writeCheckpoint) {
              return _this11.handleCrudCheckpoint(last.clientId, writeCheckpoint);
            });
            return function (_x5) {
              return _ref5.apply(this, arguments);
            };
          }(), txId);
        });
        return function (_x4) {
          return _ref4.apply(this, arguments);
        };
      }());
    })();
  }
  handleCrudCheckpoint(lastClientId, writeCheckpoint) {
    var _this12 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      return _this12.writeTransaction( /*#__PURE__*/function () {
        var _ref6 = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (tx) {
          yield tx.execute(`DELETE FROM ${_sync_bucket_BucketStorageAdapter__WEBPACK_IMPORTED_MODULE_11__.PSInternalTable.CRUD} WHERE id <= ?`, [lastClientId]);
          if (writeCheckpoint) {
            const check = yield tx.execute(`SELECT 1 FROM ${_sync_bucket_BucketStorageAdapter__WEBPACK_IMPORTED_MODULE_11__.PSInternalTable.CRUD} LIMIT 1`);
            if (!check.rows?.length) {
              yield tx.execute(`UPDATE ${_sync_bucket_BucketStorageAdapter__WEBPACK_IMPORTED_MODULE_11__.PSInternalTable.BUCKETS} SET target_op = ? WHERE name='$local'`, [writeCheckpoint]);
            }
          } else {
            yield tx.execute(`UPDATE ${_sync_bucket_BucketStorageAdapter__WEBPACK_IMPORTED_MODULE_11__.PSInternalTable.BUCKETS} SET target_op = ? WHERE name='$local'`, [_this12.bucketStorageAdapter.getMaxOpId()]);
          }
        });
        return function (_x6) {
          return _ref6.apply(this, arguments);
        };
      }());
    })();
  }
  /**
   * Execute a write (INSERT/UPDATE/DELETE) query
   * and optionally return results.
   */
  execute(sql, parameters) {
    var _this13 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _this13.waitForReady();
      return _this13.database.execute(sql, parameters);
    })();
  }
  /**
   *  Execute a read-only query and return results.
   */
  getAll(sql, parameters) {
    var _this14 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _this14.waitForReady();
      return _this14.database.getAll(sql, parameters);
    })();
  }
  /**
   * Execute a read-only query and return the first result, or null if the ResultSet is empty.
   */
  getOptional(sql, parameters) {
    var _this15 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _this15.waitForReady();
      return _this15.database.getOptional(sql, parameters);
    })();
  }
  /**
   * Execute a read-only query and return the first result, error if the ResultSet is empty.
   */
  get(sql, parameters) {
    var _this16 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _this16.waitForReady();
      return _this16.database.get(sql, parameters);
    })();
  }
  /**
   * Takes a read lock, without starting a transaction.
   * In most cases, {@link readTransaction} should be used instead.
   */
  readLock(callback) {
    var _this17 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _this17.waitForReady();
      return (0,_utils_mutex__WEBPACK_IMPORTED_MODULE_9__.mutexRunExclusive)(AbstractPowerSyncDatabase.transactionMutex, () => callback(_this17.database));
    })();
  }
  /**
   * Takes a global lock, without starting a transaction.
   * In most cases, {@link writeTransaction} should be used instead.
   */
  writeLock(callback) {
    var _this18 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _this18.waitForReady();
      return (0,_utils_mutex__WEBPACK_IMPORTED_MODULE_9__.mutexRunExclusive)(AbstractPowerSyncDatabase.transactionMutex, /*#__PURE__*/(0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        const res = yield callback(_this18.database);
        return res;
      }));
    })();
  }
  /**
   * Open a read-only transaction.
   * Read transactions can run concurrently to a write transaction.
   * Changes from any write transaction are not visible to read transactions started before it.
   */
  readTransaction(callback, lockTimeout = DEFAULT_LOCK_TIMEOUT_MS) {
    var _this19 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _this19.waitForReady();
      return _this19.database.readTransaction( /*#__PURE__*/function () {
        var _ref8 = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (tx) {
          const res = yield callback({
            ...tx
          });
          yield tx.rollback();
          return res;
        });
        return function (_x7) {
          return _ref8.apply(this, arguments);
        };
      }(), {
        timeoutMs: lockTimeout
      });
    })();
  }
  /**
   * Open a read-write transaction.
   * This takes a global lock - only one write transaction can execute against the database at a time.
   * Statements within the transaction must be done on the provided {@link Transaction} interface.
   */
  writeTransaction(callback, lockTimeout = DEFAULT_LOCK_TIMEOUT_MS) {
    var _this20 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _this20.waitForReady();
      return _this20.database.writeTransaction( /*#__PURE__*/function () {
        var _ref9 = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (tx) {
          const res = yield callback(tx);
          yield tx.commit();
          return res;
        });
        return function (_x8) {
          return _ref9.apply(this, arguments);
        };
      }(), {
        timeoutMs: lockTimeout
      });
    })();
  }
  watch(sql, parameters, handlerOrOptions, maybeOptions) {
    if (handlerOrOptions && typeof handlerOrOptions === 'object' && 'onResult' in handlerOrOptions) {
      const handler = handlerOrOptions;
      const options = maybeOptions;
      return this.watchWithCallback(sql, parameters, handler, options);
    }
    const options = handlerOrOptions;
    return this.watchWithAsyncGenerator(sql, parameters, options);
  }
  /**
   * Execute a read query every time the source tables are modified.
   * Use {@link SQLWatchOptions.throttleMs} to specify the minimum interval between queries.
   * Source tables are automatically detected using `EXPLAIN QUERY PLAN`.
   *
   * Note that the `onChange` callback member of the handler is required.
   */
  watchWithCallback(sql, parameters, handler, options) {
    var _this21 = this;
    const {
      onResult,
      onError = this.options.logger?.error
    } = handler ?? {};
    if (!onResult) {
      throw new Error('onResult is required');
    }
    (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      try {
        // Fetch initial data
        onResult(yield _this21.executeReadOnly(sql, parameters));
        const resolvedTables = yield _this21.resolveTables(sql, parameters, options);
        _this21.onChangeWithCallback({
          onChange: function () {
            var _ref11 = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
              return onResult(yield _this21.executeReadOnly(sql, parameters));
            });
            return function onChange() {
              return _ref11.apply(this, arguments);
            };
          }(),
          onError
        }, {
          ...(options ?? {}),
          tables: resolvedTables
        });
      } catch (error) {
        onError?.(error);
      }
    })();
  }
  /**
   * Execute a read query every time the source tables are modified.
   * Use {@link SQLWatchOptions.throttleMs} to specify the minimum interval between queries.
   * Source tables are automatically detected using `EXPLAIN QUERY PLAN`.
   */
  watchWithAsyncGenerator(sql, parameters, options) {
    var _this22 = this;
    return new event_iterator__WEBPACK_IMPORTED_MODULE_3__.EventIterator(eventOptions => {
      (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        // Fetch initial data
        eventOptions.push(yield _this22.executeReadOnly(sql, parameters));
        const resolvedTables = yield _this22.resolveTables(sql, parameters, options);
        var _iteratorAbruptCompletion = false;
        var _didIteratorError = false;
        var _iteratorError;
        try {
          for (var _iterator = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncIterator_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_this22.onChangeWithAsyncGenerator({
              ...(options ?? {}),
              tables: resolvedTables
            })), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {
            const event = _step.value;
            {
              eventOptions.push(yield _this22.executeReadOnly(sql, parameters));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (_iteratorAbruptCompletion && _iterator.return != null) {
              yield _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      })();
    });
  }
  resolveTables(sql, parameters, options) {
    var _this23 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const resolvedTables = options?.tables ? [...options.tables] : [];
      if (!options?.tables) {
        const explained = yield _this23.getAll(`EXPLAIN ${sql}`, parameters);
        const rootPages = explained.filter(row => row.opcode == 'OpenRead' && row.p3 == 0 && typeof row.p2 == 'number').map(row => row.p2);
        const tables = yield _this23.getAll(`SELECT DISTINCT tbl_name FROM sqlite_master WHERE rootpage IN (SELECT json_each.value FROM json_each(?))`, [JSON.stringify(rootPages)]);
        for (let table of tables) {
          resolvedTables.push(table.tbl_name.replace(POWERSYNC_TABLE_MATCH, ''));
        }
      }
      return resolvedTables;
    })();
  }
  onChange(handlerOrOptions, maybeOptions) {
    if (handlerOrOptions && typeof handlerOrOptions === 'object' && 'onChange' in handlerOrOptions) {
      const handler = handlerOrOptions;
      const options = maybeOptions;
      return this.onChangeWithCallback(handler, options);
    }
    const options = handlerOrOptions;
    return this.onChangeWithAsyncGenerator(options);
  }
  /**
  * Invoke the provided callback on any changes to any of the specified tables.
  *
  * This is preferred over {@link watchWithCallback} when multiple queries need to be performed
  * together when data is changed.
  *
  * Note that the `onChange` callback member of the handler is required.
  *
  * Returns dispose function to stop watching.
  */
  onChangeWithCallback(handler, options) {
    var _this24 = this;
    const {
      onChange,
      onError = this.options.logger?.error
    } = handler ?? {};
    if (!onChange) {
      throw new Error('onChange is required');
    }
    const resolvedOptions = options ?? {};
    const watchedTables = new Set(resolvedOptions.tables ?? []);
    const changedTables = new Set();
    const throttleMs = resolvedOptions.throttleMs ?? DEFAULT_WATCH_THROTTLE_MS;
    const flushTableUpdates = lodash_throttle__WEBPACK_IMPORTED_MODULE_5___default()(() => this.handleTableChanges(changedTables, watchedTables, intersection => {
      onChange({
        changedTables: intersection
      });
    }), throttleMs, {
      leading: false,
      trailing: true
    });
    const dispose = this.database.registerListener({
      tablesUpdated: function () {
        var _ref13 = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (update) {
          try {
            const {
              rawTableNames
            } = resolvedOptions;
            _this24.processTableUpdates(update, rawTableNames, changedTables);
            flushTableUpdates();
          } catch (error) {
            onError?.(error);
          }
        });
        return function tablesUpdated(_x9) {
          return _ref13.apply(this, arguments);
        };
      }()
    });
    resolvedOptions.signal?.addEventListener('abort', () => {
      dispose();
    });
    return () => dispose();
  }
  /**
   * Create a Stream of changes to any of the specified tables.
   *
   * This is preferred over {@link watchWithAsyncGenerator} when multiple queries need to be performed
   * together when data is changed.
   *
   * Note, do not declare this as `async *onChange` as it will not work in React Native
   */
  onChangeWithAsyncGenerator(options) {
    const resolvedOptions = options ?? {};
    return new event_iterator__WEBPACK_IMPORTED_MODULE_3__.EventIterator(eventOptions => {
      const dispose = this.onChangeWithCallback({
        onChange: event => {
          eventOptions.push(event);
        },
        onError: error => {
          eventOptions.fail(error);
        }
      }, options);
      resolvedOptions.signal?.addEventListener('abort', () => {
        eventOptions.stop();
        // Maybe fail?
      });
      return () => dispose();
    });
  }
  handleTableChanges(changedTables, watchedTables, onDetectedChanges) {
    if (changedTables.size > 0) {
      const intersection = Array.from(changedTables.values()).filter(change => watchedTables.has(change));
      if (intersection.length) {
        onDetectedChanges(intersection);
      }
    }
    changedTables.clear();
  }
  processTableUpdates(updateNotification, rawTableNames, changedTables) {
    const tables = (0,_db_DBAdapter__WEBPACK_IMPORTED_MODULE_6__.isBatchedUpdateNotification)(updateNotification) ? updateNotification.tables : [updateNotification.table];
    const filteredTables = rawTableNames ? tables : tables.filter(t => !!t.match(POWERSYNC_TABLE_MATCH));
    if (!filteredTables.length) {
      return;
    }
    // Remove any PowerSync table prefixes if necessary
    const mappedTableNames = rawTableNames ? filteredTables : filteredTables.map(t => t.replace(POWERSYNC_TABLE_MATCH, ''));
    for (let table of mappedTableNames) {
      changedTables.add(table);
    }
  }
  /**
   * @ignore
   */
  executeReadOnly(sql, params) {
    var _this25 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _this25.waitForReady();
      return _this25.database.readLock(tx => tx.execute(sql, params));
    })();
  }
}
//# sourceMappingURL=AbstractPowerSyncDatabase.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/AbstractPowerSyncOpenFactory.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/client/AbstractPowerSyncOpenFactory.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractPowerSyncDatabaseOpenFactory: () => (/* binding */ AbstractPowerSyncDatabaseOpenFactory)
/* harmony export */ });
/* harmony import */ var js_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-logger */ "./node_modules/js-logger/src/logger.js");
/* harmony import */ var js_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_logger__WEBPACK_IMPORTED_MODULE_0__);

class AbstractPowerSyncDatabaseOpenFactory {
  options;
  constructor(options) {
    this.options = options;
    options.logger = options.logger ?? js_logger__WEBPACK_IMPORTED_MODULE_0___default().get(`PowerSync ${this.options.dbFilename}`);
  }
  /**
   * Schema used for the local database.
   */
  get schema() {
    return this.options.schema;
  }
  generateOptions() {
    return {
      database: this.openDB(),
      ...this.options
    };
  }
  getInstance() {
    const options = this.generateOptions();
    return this.generateInstance(options);
  }
}
//# sourceMappingURL=AbstractPowerSyncOpenFactory.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/connection/PowerSyncBackendConnector.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/client/connection/PowerSyncBackendConnector.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=PowerSyncBackendConnector.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/connection/PowerSyncCredentials.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/client/connection/PowerSyncCredentials.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=PowerSyncCredentials.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/BucketStorageAdapter.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/BucketStorageAdapter.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PSInternalTable: () => (/* binding */ PSInternalTable)
/* harmony export */ });
var PSInternalTable = /*#__PURE__*/function (PSInternalTable) {
  PSInternalTable["DATA"] = "ps_data";
  PSInternalTable["CRUD"] = "ps_crud";
  PSInternalTable["BUCKETS"] = "ps_buckets";
  PSInternalTable["OPLOG"] = "ps_oplog";
  return PSInternalTable;
}(PSInternalTable || {});

//# sourceMappingURL=BucketStorageAdapter.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/CrudBatch.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/CrudBatch.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CrudBatch: () => (/* binding */ CrudBatch)
/* harmony export */ });
/**
 * A batch of client-side changes.
 */
class CrudBatch {
  crud;
  haveMore;
  complete;
  constructor(
  /**
   * List of client-side changes.
   */
  crud,
  /**
   * true if there are more changes in the local queue.
   */
  haveMore,
  /**
   * Call to remove the changes from the local queue, once successfully uploaded.
   */
  complete) {
    this.crud = crud;
    this.haveMore = haveMore;
    this.complete = complete;
  }
}
//# sourceMappingURL=CrudBatch.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/CrudEntry.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/CrudEntry.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CrudEntry: () => (/* binding */ CrudEntry),
/* harmony export */   UpdateType: () => (/* binding */ UpdateType)
/* harmony export */ });
/**
 * Type of local change.
 */
var UpdateType = /*#__PURE__*/function (UpdateType) {
  /** Insert or replace existing row. All non-null columns are included in the data. Generated by INSERT statements. */
  UpdateType["PUT"] = "PUT";
  /** Update existing row. Contains the id, and value of each changed column. Generated by UPDATE statements. */
  UpdateType["PATCH"] = "PATCH";
  /** Delete existing row. Contains the id. Generated by DELETE statements. */
  UpdateType["DELETE"] = "DELETE";
  return UpdateType;
}(UpdateType || {});
/**
 * A single client-side change.
 */
class CrudEntry {
  /**
   * Auto-incrementing client-side id.
   */
  clientId;
  /**
   * ID of the changed row.
   */
  id;
  /**
   * Type of change.
   */
  op;
  /**
   * Data associated with the change.
   */
  opData;
  /**
   * Table that contained the change.
   */
  table;
  /**
   * Auto-incrementing transaction id. This is the same for all operations within the same transaction.
   */
  transactionId;
  static fromRow(dbRow) {
    const data = JSON.parse(dbRow.data);
    return new CrudEntry(parseInt(dbRow.id), data.op, data.type, data.id, dbRow.tx_id, data.data);
  }
  constructor(clientId, op, table, id, transactionId, opData) {
    this.clientId = clientId;
    this.id = id;
    this.op = op;
    this.opData = opData;
    this.table = table;
    this.transactionId = transactionId;
  }
  /**
   * Converts the change to JSON format.
   */
  toJSON() {
    return {
      op_id: this.clientId,
      op: this.op,
      type: this.table,
      id: this.id,
      tx_id: this.transactionId,
      data: this.opData
    };
  }
  equals(entry) {
    return JSON.stringify(this.toComparisonArray()) == JSON.stringify(entry.toComparisonArray());
  }
  /**
   * The hash code for this object.
   * @deprecated This should not be necessary in the JS SDK.
   * Use the  @see CrudEntry#equals method instead.
   * TODO remove in the next major release.
   */
  hashCode() {
    return JSON.stringify(this.toComparisonArray());
  }
  /**
   * Generates an array for use in deep comparison operations
   */
  toComparisonArray() {
    return [this.transactionId, this.clientId, this.op, this.table, this.id, this.opData];
  }
}
//# sourceMappingURL=CrudEntry.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/CrudTransaction.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/CrudTransaction.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CrudTransaction: () => (/* binding */ CrudTransaction)
/* harmony export */ });
/* harmony import */ var _CrudBatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CrudBatch */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/CrudBatch.js");

class CrudTransaction extends _CrudBatch__WEBPACK_IMPORTED_MODULE_0__.CrudBatch {
  crud;
  complete;
  transactionId;
  constructor(
  /**
   * List of client-side changes.
   */
  crud,
  /**
   * Call to remove the changes from the local queue, once successfully uploaded.
   */
  complete,
  /**
   * If null, this contains a list of changes recorded without an explicit transaction associated.
   */
  transactionId) {
    super(crud, false, complete);
    this.crud = crud;
    this.complete = complete;
    this.transactionId = transactionId;
  }
}
//# sourceMappingURL=CrudTransaction.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/OpType.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/OpType.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OpType: () => (/* binding */ OpType),
/* harmony export */   OpTypeEnum: () => (/* binding */ OpTypeEnum)
/* harmony export */ });
var OpTypeEnum = /*#__PURE__*/function (OpTypeEnum) {
  OpTypeEnum[OpTypeEnum["CLEAR"] = 1] = "CLEAR";
  OpTypeEnum[OpTypeEnum["MOVE"] = 2] = "MOVE";
  OpTypeEnum[OpTypeEnum["PUT"] = 3] = "PUT";
  OpTypeEnum[OpTypeEnum["REMOVE"] = 4] = "REMOVE";
  return OpTypeEnum;
}(OpTypeEnum || {});
/**
 * Used internally for sync buckets.
 */
class OpType {
  value;
  static fromJSON(jsonValue) {
    return new OpType(OpTypeEnum[jsonValue]);
  }
  constructor(value) {
    this.value = value;
  }
  toJSON() {
    return Object.entries(OpTypeEnum).find(([, value]) => value === this.value)[0];
  }
}
//# sourceMappingURL=OpType.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/OplogEntry.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/OplogEntry.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OplogEntry: () => (/* binding */ OplogEntry)
/* harmony export */ });
/* harmony import */ var _OpType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OpType */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/OpType.js");

class OplogEntry {
  op_id;
  op;
  checksum;
  subkey;
  object_type;
  object_id;
  data;
  static fromRow(row) {
    return new OplogEntry(row.op_id, _OpType__WEBPACK_IMPORTED_MODULE_0__.OpType.fromJSON(row.op), row.checksum, typeof row.subkey == 'string' ? row.subkey : JSON.stringify(row.subkey), row.object_type, row.object_id, row.data);
  }
  constructor(op_id, op, checksum, subkey, object_type, object_id, data) {
    this.op_id = op_id;
    this.op = op;
    this.checksum = checksum;
    this.subkey = subkey;
    this.object_type = object_type;
    this.object_id = object_id;
    this.data = data;
  }
  toJSON() {
    return {
      op_id: this.op_id,
      op: this.op.toJSON(),
      object_type: this.object_type,
      object_id: this.object_id,
      checksum: this.checksum,
      data: this.data,
      subkey: JSON.stringify(this.subkey)
    };
  }
}
//# sourceMappingURL=OplogEntry.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/SqliteBucketStorage.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/SqliteBucketStorage.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SqliteBucketStorage: () => (/* binding */ SqliteBucketStorage)
/* harmony export */ });
/* harmony import */ var C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ "./node_modules/@journeyapps/powersync-sdk-common/node_modules/uuid/index.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(uuid__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _db_DBAdapter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../db/DBAdapter */ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/DBAdapter.js");
/* harmony import */ var _BucketStorageAdapter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BucketStorageAdapter */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/BucketStorageAdapter.js");
/* harmony import */ var _OpType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./OpType */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/OpType.js");
/* harmony import */ var _CrudEntry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CrudEntry */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/CrudEntry.js");
/* harmony import */ var js_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! js-logger */ "./node_modules/js-logger/src/logger.js");
/* harmony import */ var js_logger__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(js_logger__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _utils_BaseObserver__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../utils/BaseObserver */ "./node_modules/@journeyapps/powersync-sdk-common/lib/utils/BaseObserver.js");








const COMPACT_OPERATION_INTERVAL = 1_000;
let SqliteBucketStorage = /*#__PURE__*/(() => {
  class SqliteBucketStorage extends _utils_BaseObserver__WEBPACK_IMPORTED_MODULE_7__.BaseObserver {
    db;
    mutex;
    logger;
    static MAX_OP_ID = '9223372036854775807';
    tableNames;
    pendingBucketDeletes;
    _hasCompletedSync;
    updateListener;
    /**
     * Count up, and do a compact on startup.
     */
    compactCounter = COMPACT_OPERATION_INTERVAL;
    constructor(db, mutex, logger = js_logger__WEBPACK_IMPORTED_MODULE_6___default().get('SqliteBucketStorage')) {
      super();
      this.db = db;
      this.mutex = mutex;
      this.logger = logger;
      this._hasCompletedSync = false;
      this.pendingBucketDeletes = true;
      this.tableNames = new Set();
      this.updateListener = db.registerListener({
        tablesUpdated: update => {
          const tables = (0,_db_DBAdapter__WEBPACK_IMPORTED_MODULE_2__.extractTableUpdates)(update);
          if (tables.includes(_BucketStorageAdapter__WEBPACK_IMPORTED_MODULE_3__.PSInternalTable.CRUD)) {
            this.iterateListeners(l => l.crudUpdate?.());
          }
        }
      });
    }
    init() {
      var _this = this;
      return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        _this._hasCompletedSync = false;
        const existingTableRows = yield _this.db.execute(`SELECT name FROM sqlite_master WHERE type='table' AND name GLOB 'ps_data_*'`);
        for (const row of existingTableRows.rows?._array ?? []) {
          _this.tableNames.add(row.name);
        }
      })();
    }
    dispose() {
      var _this2 = this;
      return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        _this2.updateListener?.();
      })();
    }
    getMaxOpId() {
      return SqliteBucketStorage.MAX_OP_ID;
    }
    /**
     * Reset any caches.
     */
    startSession() {}
    getBucketStates() {
      var _this3 = this;
      return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        const result = yield _this3.db.execute('SELECT name as bucket, cast(last_op as TEXT) as op_id FROM ps_buckets WHERE pending_delete = 0');
        return result.rows?._array ?? [];
      })();
    }
    saveSyncData(batch) {
      var _this4 = this;
      return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        yield _this4.writeTransaction( /*#__PURE__*/function () {
          var _ref = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (tx) {
            let count = 0;
            for (const b of batch.buckets) {
              const result = yield tx.execute('INSERT INTO powersync_operations(op, data) VALUES(?, ?)', ['save', JSON.stringify({
                buckets: [b.toJSON()]
              })]);
              _this4.logger.debug('saveSyncData', JSON.stringify(result));
              count += b.data.length;
            }
            _this4.compactCounter += count;
          });
          return function (_x) {
            return _ref.apply(this, arguments);
          };
        }());
      })();
    }
    removeBuckets(buckets) {
      var _this5 = this;
      return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        for (const bucket of buckets) {
          yield _this5.deleteBucket(bucket);
        }
      })();
    }
    /**
     * Mark a bucket for deletion.
     */
    deleteBucket(bucket) {
      var _this6 = this;
      return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        // Delete a bucket, but allow it to be re-created.
        // To achieve this, we rename the bucket to a new temp name, and change all ops to remove.
        // By itself, this new bucket would ensure that the previous objects are deleted if they contain no more references.
        // If the old bucket is re-added, this new bucket would have no effect.
        const newName = `$delete_${bucket}_${(0,uuid__WEBPACK_IMPORTED_MODULE_1__.v4)()}`;
        _this6.logger.debug('Deleting bucket', bucket);
        // This
        yield _this6.writeTransaction( /*#__PURE__*/function () {
          var _ref2 = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (tx) {
            yield tx.execute(`UPDATE ps_oplog SET op=${_OpType__WEBPACK_IMPORTED_MODULE_4__.OpTypeEnum.REMOVE}, data=NULL WHERE op=${_OpType__WEBPACK_IMPORTED_MODULE_4__.OpTypeEnum.PUT} AND superseded=0 AND bucket=?`, [bucket]);
            // Rename bucket
            yield tx.execute('UPDATE ps_oplog SET bucket=? WHERE bucket=?', [newName, bucket]);
            yield tx.execute('DELETE FROM ps_buckets WHERE name = ?', [bucket]);
            yield tx.execute('INSERT INTO ps_buckets(name, pending_delete, last_op) SELECT ?, 1, IFNULL(MAX(op_id), 0) FROM ps_oplog WHERE bucket = ?', [newName, newName]);
          });
          return function (_x2) {
            return _ref2.apply(this, arguments);
          };
        }());
        _this6.logger.debug('done deleting bucket');
        _this6.pendingBucketDeletes = true;
      })();
    }
    hasCompletedSync() {
      var _this7 = this;
      return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        if (_this7._hasCompletedSync) {
          return true;
        }
        const r = yield _this7.db.execute(`SELECT name, last_applied_op FROM ps_buckets WHERE last_applied_op > 0 LIMIT 1`);
        const completed = !!r.rows?.length;
        if (completed) {
          _this7._hasCompletedSync = true;
        }
        return completed;
      })();
    }
    syncLocalDatabase(checkpoint) {
      var _this8 = this;
      return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        const r = yield _this8.validateChecksums(checkpoint);
        if (!r.checkpointValid) {
          _this8.logger.error('Checksums failed for', r.checkpointFailures);
          for (const b of r.checkpointFailures ?? []) {
            yield _this8.deleteBucket(b);
          }
          return {
            ready: false,
            checkpointValid: false,
            checkpointFailures: r.checkpointFailures
          };
        }
        const bucketNames = checkpoint.buckets.map(b => b.bucket);
        yield _this8.writeTransaction( /*#__PURE__*/function () {
          var _ref3 = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (tx) {
            yield tx.execute(`UPDATE ps_buckets SET last_op = ? WHERE name IN (SELECT json_each.value FROM json_each(?))`, [checkpoint.last_op_id, JSON.stringify(bucketNames)]);
            if (checkpoint.write_checkpoint) {
              yield tx.execute("UPDATE ps_buckets SET last_op = ? WHERE name = '$local'", [checkpoint.write_checkpoint]);
            }
          });
          return function (_x3) {
            return _ref3.apply(this, arguments);
          };
        }());
        const valid = yield _this8.updateObjectsFromBuckets(checkpoint);
        if (!valid) {
          _this8.logger.debug('Not at a consistent checkpoint - cannot update local db');
          return {
            ready: false,
            checkpointValid: true
          };
        }
        yield _this8.forceCompact();
        return {
          ready: true,
          checkpointValid: true
        };
      })();
    }
    /**
     * Atomically update the local state to the current checkpoint.
     *
     * This includes creating new tables, dropping old tables, and copying data over from the oplog.
     */
    updateObjectsFromBuckets(checkpoint) {
      var _this9 = this;
      return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        return _this9.writeTransaction( /*#__PURE__*/function () {
          var _ref4 = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (tx) {
            const {
              insertId: result
            } = yield tx.execute('INSERT INTO powersync_operations(op, data) VALUES(?, ?)', ['sync_local', '']);
            return result == 1;
          });
          return function (_x4) {
            return _ref4.apply(this, arguments);
          };
        }());
      })();
    }
    validateChecksums(checkpoint) {
      var _this10 = this;
      return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        const rs = yield _this10.db.execute('SELECT powersync_validate_checkpoint(?) as result', [JSON.stringify(checkpoint)]);
        const resultItem = rs.rows?.item(0);
        _this10.logger.debug('validateChecksums result item', resultItem);
        if (!resultItem) {
          return {
            checkpointValid: false,
            ready: false,
            checkpointFailures: []
          };
        }
        const result = JSON.parse(resultItem['result']);
        if (result['valid']) {
          return {
            ready: true,
            checkpointValid: true
          };
        } else {
          return {
            checkpointValid: false,
            ready: false,
            checkpointFailures: result['failed_buckets']
          };
        }
      })();
    }
    /**
     * Force a compact, for tests.
     */
    forceCompact() {
      var _this11 = this;
      return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        _this11.compactCounter = COMPACT_OPERATION_INTERVAL;
        _this11.pendingBucketDeletes = true;
        yield _this11.autoCompact();
      })();
    }
    autoCompact() {
      var _this12 = this;
      return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        yield _this12.deletePendingBuckets();
        yield _this12.clearRemoveOps();
      })();
    }
    deletePendingBuckets() {
      var _this13 = this;
      return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        if (_this13.pendingBucketDeletes !== false) {
          yield _this13.writeTransaction( /*#__PURE__*/function () {
            var _ref5 = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (tx) {
              yield tx.execute('DELETE FROM ps_oplog WHERE bucket IN (SELECT name FROM ps_buckets WHERE pending_delete = 1 AND last_applied_op = last_op AND last_op >= target_op)');
              yield tx.execute('DELETE FROM ps_buckets WHERE pending_delete = 1 AND last_applied_op = last_op AND last_op >= target_op');
            });
            return function (_x5) {
              return _ref5.apply(this, arguments);
            };
          }());
          // Executed once after start-up, and again when there are pending deletes.
          _this13.pendingBucketDeletes = false;
        }
      })();
    }
    clearRemoveOps() {
      var _this14 = this;
      return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        if (_this14.compactCounter < COMPACT_OPERATION_INTERVAL) {
          return;
        }
        yield _this14.writeTransaction( /*#__PURE__*/function () {
          var _ref6 = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (tx) {
            yield tx.execute('INSERT INTO powersync_operations(op, data) VALUES (?, ?)', ['clear_remove_ops', '']);
          });
          return function (_x6) {
            return _ref6.apply(this, arguments);
          };
        }());
        _this14.compactCounter = 0;
      })();
    }
    updateLocalTarget(cb) {
      var _this15 = this;
      return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        const rs1 = yield _this15.db.execute("SELECT target_op FROM ps_buckets WHERE name = '$local' AND target_op = ?", [SqliteBucketStorage.MAX_OP_ID]);
        if (!rs1.rows?.length) {
          // Nothing to update
          return false;
        }
        const rs = yield _this15.db.execute("SELECT seq FROM sqlite_sequence WHERE name = 'ps_crud'");
        if (!rs.rows?.length) {
          // Nothing to update
          return false;
        }
        const seqBefore = rs.rows?.item(0)['seq'];
        const opId = yield cb();
        _this15.logger.debug(`[updateLocalTarget] Updating target to checkpoint ${opId}`);
        return _this15.writeTransaction( /*#__PURE__*/function () {
          var _ref7 = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (tx) {
            const anyData = yield tx.execute('SELECT 1 FROM ps_crud LIMIT 1');
            if (anyData.rows?.length) {
              // if isNotEmpty
              _this15.logger.debug('updateLocalTarget', 'ps crud is not empty');
              return false;
            }
            const rs = yield tx.execute("SELECT seq FROM sqlite_sequence WHERE name = 'ps_crud'");
            if (!rs.rows?.length) {
              // assert isNotEmpty
              throw new Error('SQlite Sequence should not be empty');
            }
            const seqAfter = rs.rows?.item(0)['seq'];
            _this15.logger.debug('seqAfter', JSON.stringify(rs.rows?.item(0)));
            if (seqAfter != seqBefore) {
              _this15.logger.debug('seqAfter != seqBefore', seqAfter, seqBefore);
              // New crud data may have been uploaded since we got the checkpoint. Abort.
              return false;
            }
            const response = yield tx.execute("UPDATE ps_buckets SET target_op = ? WHERE name='$local'", [opId]);
            _this15.logger.debug(['[updateLocalTarget] Response from updating target_op ', JSON.stringify(response)]);
            return true;
          });
          return function (_x7) {
            return _ref7.apply(this, arguments);
          };
        }());
      })();
    }
    hasCrud() {
      var _this16 = this;
      return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        const anyData = yield _this16.db.execute('SELECT 1 FROM ps_crud LIMIT 1');
        return !!anyData.rows?.length;
      })();
    }
    /**
     * Get a batch of objects to send to the server.
     * When the objects are successfully sent to the server, call .complete()
     */
    getCrudBatch(limit = 100) {
      var _this17 = this;
      return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        if (!(yield _this17.hasCrud())) {
          return null;
        }
        const crudResult = yield _this17.db.execute('SELECT * FROM ps_crud ORDER BY id ASC LIMIT ?', [limit]);
        const all = [];
        for (const row of crudResult.rows?._array ?? []) {
          all.push(_CrudEntry__WEBPACK_IMPORTED_MODULE_5__.CrudEntry.fromRow(row));
        }
        if (all.length === 0) {
          return null;
        }
        const last = all[all.length - 1];
        return {
          crud: all,
          haveMore: true,
          complete: function () {
            var _ref8 = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (writeCheckpoint) {
              return _this17.writeTransaction( /*#__PURE__*/function () {
                var _ref9 = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (tx) {
                  yield tx.execute('DELETE FROM ps_crud WHERE id <= ?', [last.clientId]);
                  if (writeCheckpoint) {
                    const crudResult = yield tx.execute('SELECT 1 FROM ps_crud LIMIT 1');
                    if (crudResult.rows?.length) {
                      yield tx.execute("UPDATE ps_buckets SET target_op = ? WHERE name='$local'", [writeCheckpoint]);
                    }
                  } else {
                    yield tx.execute("UPDATE ps_buckets SET target_op = ? WHERE name='$local'", [_this17.getMaxOpId()]);
                  }
                });
                return function (_x9) {
                  return _ref9.apply(this, arguments);
                };
              }());
            });
            return function complete(_x8) {
              return _ref8.apply(this, arguments);
            };
          }()
        };
      })();
    }
    writeTransaction(callback, options) {
      var _this18 = this;
      return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        return _this18.db.writeTransaction(callback, options);
      })();
    }
    /**
     * Set a target checkpoint.
     */
    setTargetCheckpoint(checkpoint) {
      return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {})();
    } // No-op for now
  }
  return SqliteBucketStorage;
})();
//# sourceMappingURL=SqliteBucketStorage.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/SyncDataBatch.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/SyncDataBatch.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SyncDataBatch: () => (/* binding */ SyncDataBatch)
/* harmony export */ });
/* harmony import */ var _SyncDataBucket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SyncDataBucket */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/SyncDataBucket.js");

// TODO JSON
class SyncDataBatch {
  buckets;
  static fromJSON(json) {
    return new SyncDataBatch(json.buckets.map(bucket => _SyncDataBucket__WEBPACK_IMPORTED_MODULE_0__.SyncDataBucket.fromRow(bucket)));
  }
  constructor(buckets) {
    this.buckets = buckets;
  }
}
//# sourceMappingURL=SyncDataBatch.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/SyncDataBucket.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/SyncDataBucket.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MAX_OP_ID: () => (/* binding */ MAX_OP_ID),
/* harmony export */   SyncDataBucket: () => (/* binding */ SyncDataBucket)
/* harmony export */ });
/* harmony import */ var _OplogEntry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OplogEntry */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/OplogEntry.js");

const MAX_OP_ID = '9223372036854775807';
class SyncDataBucket {
  bucket;
  data;
  has_more;
  after;
  next_after;
  static fromRow(row) {
    return new SyncDataBucket(row.bucket, row.data.map(entry => _OplogEntry__WEBPACK_IMPORTED_MODULE_0__.OplogEntry.fromRow(entry)), row.has_more ?? false, row.after, row.next_after);
  }
  constructor(bucket, data,
  /**
   * True if the response does not contain all the data for this bucket, and another request must be made.
   */
  has_more,
  /**
   * The `after` specified in the request.
   */
  after,
  /**
   * Use this for the next request.
   */
  next_after) {
    this.bucket = bucket;
    this.data = data;
    this.has_more = has_more;
    this.after = after;
    this.next_after = next_after;
  }
  toJSON() {
    return {
      bucket: this.bucket,
      has_more: this.has_more,
      after: this.after,
      next_after: this.next_after,
      data: this.data.map(entry => entry.toJSON())
    };
  }
}
//# sourceMappingURL=SyncDataBucket.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/stream/AbstractRemote.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/stream/AbstractRemote.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractRemote: () => (/* binding */ AbstractRemote),
/* harmony export */   DEFAULT_REMOTE_LOGGER: () => (/* binding */ DEFAULT_REMOTE_LOGGER)
/* harmony export */ });
/* harmony import */ var C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var js_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-logger */ "./node_modules/js-logger/src/logger.js");
/* harmony import */ var js_logger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(js_logger__WEBPACK_IMPORTED_MODULE_1__);


// Refresh at least 30 sec before it expires
const REFRESH_CREDENTIALS_SAFETY_PERIOD_MS = 30_000;
const DEFAULT_REMOTE_LOGGER = js_logger__WEBPACK_IMPORTED_MODULE_1___default().get('PowerSyncRemote');
class AbstractRemote {
  connector;
  logger;
  credentials = null;
  constructor(connector, logger = DEFAULT_REMOTE_LOGGER) {
    this.connector = connector;
    this.logger = logger;
  }
  getCredentials() {
    var _this = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const {
        expiresAt
      } = _this.credentials ?? {};
      if (expiresAt && expiresAt > new Date(new Date().valueOf() + REFRESH_CREDENTIALS_SAFETY_PERIOD_MS)) {
        return _this.credentials;
      }
      _this.credentials = yield _this.connector.fetchCredentials();
      return _this.credentials;
    })();
  }
  buildRequest(path) {
    var _this2 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const credentials = yield _this2.getCredentials();
      if (credentials != null && (credentials.endpoint == null || credentials.endpoint == '')) {
        throw new Error('PowerSync endpoint not configured');
      } else if (credentials?.token == null || credentials?.token == '') {
        const error = new Error(`Not signed in`);
        error.status = 401;
        throw error;
      }
      return {
        url: credentials.endpoint + path,
        headers: {
          'content-type': 'application/json',
          Authorization: `Token ${credentials.token}`
        }
      };
    })();
  }
  isAvailable() {
    return true;
  }
}
//# sourceMappingURL=AbstractRemote.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/stream/AbstractStreamingSyncImplementation.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/stream/AbstractStreamingSyncImplementation.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractStreamingSyncImplementation: () => (/* binding */ AbstractStreamingSyncImplementation),
/* harmony export */   DEFAULT_CRUD_UPLOAD_THROTTLE_MS: () => (/* binding */ DEFAULT_CRUD_UPLOAD_THROTTLE_MS),
/* harmony export */   DEFAULT_STREAMING_SYNC_OPTIONS: () => (/* binding */ DEFAULT_STREAMING_SYNC_OPTIONS),
/* harmony export */   LockType: () => (/* binding */ LockType)
/* harmony export */ });
/* harmony import */ var C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_awaitAsyncGenerator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js */ "./node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js");
/* harmony import */ var C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_wrapAsyncGenerator_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js */ "./node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js");
/* harmony import */ var C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncIterator_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncIterator.js */ "./node_modules/@babel/runtime/helpers/esm/asyncIterator.js");
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/throttle */ "./node_modules/lodash/throttle.js");
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var js_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! js-logger */ "./node_modules/js-logger/src/logger.js");
/* harmony import */ var js_logger__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(js_logger__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _streaming_sync_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./streaming-sync-types */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/stream/streaming-sync-types.js");
/* harmony import */ var can_ndjson_stream__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! can-ndjson-stream */ "./node_modules/can-ndjson-stream/can-ndjson-stream.js");
/* harmony import */ var can_ndjson_stream__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(can_ndjson_stream__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _db_crud_SyncStatus__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../db/crud/SyncStatus */ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/crud/SyncStatus.js");
/* harmony import */ var _bucket_SyncDataBucket__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../bucket/SyncDataBucket */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/SyncDataBucket.js");
/* harmony import */ var _utils_BaseObserver__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../utils/BaseObserver */ "./node_modules/@journeyapps/powersync-sdk-common/lib/utils/BaseObserver.js");











var LockType = /*#__PURE__*/function (LockType) {
  LockType["CRUD"] = "crud";
  LockType["SYNC"] = "sync";
  return LockType;
}(LockType || {});
const DEFAULT_CRUD_UPLOAD_THROTTLE_MS = 1000;
const DEFAULT_STREAMING_SYNC_OPTIONS = {
  retryDelayMs: 5000,
  logger: js_logger__WEBPACK_IMPORTED_MODULE_5___default().get('PowerSyncStream'),
  crudUploadThrottleMs: DEFAULT_CRUD_UPLOAD_THROTTLE_MS
};
class AbstractStreamingSyncImplementation extends _utils_BaseObserver__WEBPACK_IMPORTED_MODULE_10__.BaseObserver {
  _lastSyncedAt;
  options;
  abortController;
  crudUpdateListener;
  syncStatus;
  triggerCrudUpload;
  constructor(options) {
    super();
    this.options = {
      ...DEFAULT_STREAMING_SYNC_OPTIONS,
      ...options
    };
    this.syncStatus = new _db_crud_SyncStatus__WEBPACK_IMPORTED_MODULE_8__.SyncStatus({
      connected: false,
      lastSyncedAt: undefined,
      dataFlow: {
        uploading: false,
        downloading: false
      }
    });
    this.abortController = null;
    this.triggerCrudUpload = lodash_throttle__WEBPACK_IMPORTED_MODULE_4___default()(() => {
      if (!this.syncStatus.connected || this.syncStatus.dataFlowStatus.uploading) {
        return;
      }
      this._uploadAllCrud();
    }, this.options.crudUploadThrottleMs, {
      trailing: true
    });
  }
  waitForReady() {
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {})();
  }
  waitForStatus(status) {
    return new Promise(resolve => {
      const l = this.registerListener({
        statusChanged: updatedStatus => {
          /**
           * Match only the partial status options provided in the
           * matching status
           */
          const matchPartialObject = (compA, compB) => {
            return Object.entries(compA).every(([key, value]) => {
              const comparisonBValue = compB[key];
              if (typeof value == 'object' && typeof comparisonBValue == 'object') {
                return matchPartialObject(value, comparisonBValue);
              }
              return value == comparisonBValue;
            });
          };
          if (matchPartialObject(status, updatedStatus.toJSON())) {
            resolve();
            l?.();
          }
        }
      });
    });
  }
  get lastSyncedAt() {
    const lastSynced = this.syncStatus.lastSyncedAt;
    return lastSynced && new Date(lastSynced);
  }
  get isConnected() {
    return this.syncStatus.connected;
  }
  get logger() {
    return this.options.logger;
  }
  dispose() {
    var _this2 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _this2.crudUpdateListener?.();
      _this2.crudUpdateListener = undefined;
    })();
  }
  hasCompletedSync() {
    var _this3 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      return _this3.options.adapter.hasCompletedSync();
    })();
  }
  getWriteCheckpoint() {
    var _this4 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const response = yield _this4.options.remote.get('/write-checkpoint2.json');
      return response['data']['write_checkpoint'];
    })();
  }
  _uploadAllCrud() {
    var _this5 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      return _this5.obtainLock({
        type: LockType.CRUD,
        callback: function () {
          var _ref = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
            _this5.updateSyncStatus({
              dataFlow: {
                uploading: true
              }
            });
            while (true) {
              try {
                const done = yield _this5.uploadCrudBatch();
                if (done) {
                  break;
                }
              } catch (ex) {
                _this5.updateSyncStatus({
                  connected: false,
                  dataFlow: {
                    uploading: false
                  }
                });
                yield _this5.delayRetry();
                break;
              } finally {
                _this5.updateSyncStatus({
                  dataFlow: {
                    uploading: false
                  }
                });
              }
            }
          });
          return function callback() {
            return _ref.apply(this, arguments);
          };
        }()
      });
    })();
  }
  uploadCrudBatch() {
    var _this6 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const hasCrud = yield _this6.options.adapter.hasCrud();
      if (hasCrud) {
        yield _this6.options.uploadCrud();
        return false;
      } else {
        yield _this6.options.adapter.updateLocalTarget(() => _this6.getWriteCheckpoint());
        return true;
      }
    })();
  }
  connect() {
    var _this7 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (_this7.abortController) {
        yield _this7.disconnect();
      }
      _this7.abortController = new AbortController();
      _this7.streamingSync(_this7.abortController.signal);
      return _this7.waitForStatus({
        connected: true
      });
    })();
  }
  disconnect() {
    var _this8 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (!_this8.abortController) {
        throw new Error('Disconnect not possible');
      }
      _this8.abortController.abort('Disconnected');
      _this8.abortController = null;
      _this8.updateSyncStatus({
        connected: false
      });
    })();
  }
  /**
   * @deprecated use [connect instead]
   */
  streamingSync(signal) {
    var _this9 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (!signal) {
        _this9.abortController = new AbortController();
        signal = _this9.abortController.signal;
      }
      /**
       * Listen for CRUD updates and trigger upstream uploads
       */
      _this9.crudUpdateListener = _this9.options.adapter.registerListener({
        crudUpdate: () => _this9.triggerCrudUpload()
      });
      /**
       * Create a new abort controller which aborts items downstream.
       * This is needed to close any previous connections on exception.
       */
      let nestedAbortController = new AbortController();
      signal.addEventListener('abort', () => {
        nestedAbortController.abort();
        _this9.crudUpdateListener?.();
        _this9.crudUpdateListener = undefined;
        _this9.updateSyncStatus({
          connected: false,
          dataFlow: {
            downloading: false
          }
        });
      });
      while (true) {
        try {
          if (signal?.aborted) {
            break;
          }
          const {
            retry
          } = yield _this9.streamingSyncIteration(nestedAbortController.signal);
          if (!retry) {
            break;
          }
          // Continue immediately
        } catch (ex) {
          _this9.logger.error(ex);
          _this9.updateSyncStatus({
            connected: false
          });
          // On error, wait a little before retrying
          yield _this9.delayRetry();
        } finally {
          // Abort any open network requests. Create a new nested controller for retry.
          nestedAbortController.abort();
          nestedAbortController = new AbortController();
        }
      }
      // Mark as disconnected if here
      if (_this9.abortController) {
        yield _this9.disconnect();
      }
    })();
  }
  streamingSyncIteration(signal, progress) {
    var _this10 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      return yield _this10.obtainLock({
        type: LockType.SYNC,
        signal,
        callback: function () {
          var _ref2 = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
            _this10.logger.debug('Streaming sync iteration started');
            _this10.options.adapter.startSession();
            const bucketEntries = yield _this10.options.adapter.getBucketStates();
            const initialBuckets = new Map();
            bucketEntries.forEach(entry => {
              initialBuckets.set(entry.bucket, entry.op_id);
            });
            const req = Array.from(initialBuckets.entries()).map(([bucket, after]) => ({
              name: bucket,
              after: after
            }));
            // These are compared by reference
            let targetCheckpoint = null;
            let validatedCheckpoint = null;
            let appliedCheckpoint = null;
            let bucketSet = new Set(initialBuckets.keys());
            var _iteratorAbruptCompletion = false;
            var _didIteratorError = false;
            var _iteratorError;
            try {
              for (var _iterator = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncIterator_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_this10.streamingSyncRequest({
                  buckets: req,
                  include_checksum: true,
                  raw_data: true
                }, signal)), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {
                const line = _step.value;
                {
                  // A connection is active and messages are being received
                  if (!_this10.syncStatus.connected) {
                    // There is a connection now
                    Promise.resolve().then(() => _this10.triggerCrudUpload());
                    _this10.updateSyncStatus({
                      connected: true
                    });
                  }
                  if ((0,_streaming_sync_types__WEBPACK_IMPORTED_MODULE_6__.isStreamingSyncCheckpoint)(line)) {
                    targetCheckpoint = line.checkpoint;
                    const bucketsToDelete = new Set(bucketSet);
                    const newBuckets = new Set();
                    for (const checksum of line.checkpoint.buckets) {
                      newBuckets.add(checksum.bucket);
                      bucketsToDelete.delete(checksum.bucket);
                    }
                    if (bucketsToDelete.size > 0) {
                      _this10.logger.debug('Removing buckets', [...bucketsToDelete]);
                    }
                    bucketSet = newBuckets;
                    yield _this10.options.adapter.removeBuckets([...bucketsToDelete]);
                    yield _this10.options.adapter.setTargetCheckpoint(targetCheckpoint);
                  } else if ((0,_streaming_sync_types__WEBPACK_IMPORTED_MODULE_6__.isStreamingSyncCheckpointComplete)(line)) {
                    _this10.logger.debug('Checkpoint complete', targetCheckpoint);
                    const result = yield _this10.options.adapter.syncLocalDatabase(targetCheckpoint);
                    if (!result.checkpointValid) {
                      // This means checksums failed. Start again with a new checkpoint.
                      // TODO: better back-off
                      yield new Promise(resolve => setTimeout(resolve, 50));
                      return {
                        retry: true
                      };
                    } else if (!result.ready) {
                      // Checksums valid, but need more data for a consistent checkpoint.
                      // Continue waiting.
                      // landing here the whole time
                    } else {
                      appliedCheckpoint = targetCheckpoint;
                      _this10.logger.debug('validated checkpoint', appliedCheckpoint);
                      _this10.updateSyncStatus({
                        connected: true,
                        lastSyncedAt: new Date(),
                        dataFlow: {
                          downloading: false
                        }
                      });
                    }
                    validatedCheckpoint = targetCheckpoint;
                  } else if ((0,_streaming_sync_types__WEBPACK_IMPORTED_MODULE_6__.isStreamingSyncCheckpointDiff)(line)) {
                    // TODO: It may be faster to just keep track of the diff, instead of the entire checkpoint
                    if (targetCheckpoint == null) {
                      throw new Error('Checkpoint diff without previous checkpoint');
                    }
                    const diff = line.checkpoint_diff;
                    const newBuckets = new Map();
                    for (const checksum of targetCheckpoint.buckets) {
                      newBuckets.set(checksum.bucket, checksum);
                    }
                    for (const checksum of diff.updated_buckets) {
                      newBuckets.set(checksum.bucket, checksum);
                    }
                    for (const bucket of diff.removed_buckets) {
                      newBuckets.delete(bucket);
                    }
                    const newCheckpoint = {
                      last_op_id: diff.last_op_id,
                      buckets: [...newBuckets.values()],
                      write_checkpoint: diff.write_checkpoint
                    };
                    targetCheckpoint = newCheckpoint;
                    bucketSet = new Set(newBuckets.keys());
                    const bucketsToDelete = diff.removed_buckets;
                    if (bucketsToDelete.length > 0) {
                      _this10.logger.debug('Remove buckets', bucketsToDelete);
                    }
                    yield _this10.options.adapter.removeBuckets(bucketsToDelete);
                    yield _this10.options.adapter.setTargetCheckpoint(targetCheckpoint);
                  } else if ((0,_streaming_sync_types__WEBPACK_IMPORTED_MODULE_6__.isStreamingSyncData)(line)) {
                    const {
                      data
                    } = line;
                    _this10.updateSyncStatus({
                      dataFlow: {
                        downloading: true
                      }
                    });
                    yield _this10.options.adapter.saveSyncData({
                      buckets: [_bucket_SyncDataBucket__WEBPACK_IMPORTED_MODULE_9__.SyncDataBucket.fromRow(data)]
                    });
                  } else if ((0,_streaming_sync_types__WEBPACK_IMPORTED_MODULE_6__.isStreamingKeepalive)(line)) {
                    const remaining_seconds = line.token_expires_in;
                    if (remaining_seconds == 0) {
                      // Connection would be closed automatically right after this
                      _this10.logger.debug('Token expiring; reconnect');
                      return {
                        retry: true
                      };
                    }
                    _this10.triggerCrudUpload();
                  } else {
                    _this10.logger.debug('Sync complete');
                    if (targetCheckpoint === appliedCheckpoint) {
                      _this10.updateSyncStatus({
                        connected: true,
                        lastSyncedAt: new Date()
                      });
                    } else if (validatedCheckpoint === targetCheckpoint) {
                      const result = yield _this10.options.adapter.syncLocalDatabase(targetCheckpoint);
                      if (!result.checkpointValid) {
                        // This means checksums failed. Start again with a new checkpoint.
                        // TODO: better back-off
                        yield new Promise(resolve => setTimeout(resolve, 50));
                        return {
                          retry: false
                        };
                      } else if (!result.ready) {
                        // Checksums valid, but need more data for a consistent checkpoint.
                        // Continue waiting.
                      } else {
                        appliedCheckpoint = targetCheckpoint;
                        _this10.updateSyncStatus({
                          connected: true,
                          lastSyncedAt: new Date(),
                          dataFlow: {
                            downloading: false
                          }
                        });
                      }
                    }
                  }
                  progress?.();
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (_iteratorAbruptCompletion && _iterator.return != null) {
                  yield _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
            _this10.logger.debug('Stream input empty');
            // Connection closed. Likely due to auth issue.
            return {
              retry: true
            };
          });
          return function callback() {
            return _ref2.apply(this, arguments);
          };
        }()
      });
    })();
  }
  streamingSyncRequest(req, signal) {
    var _this = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_wrapAsyncGenerator_js__WEBPACK_IMPORTED_MODULE_2__["default"])(function* () {
      const body = yield (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_awaitAsyncGenerator_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.options.remote.postStreaming('/sync/stream', req, {}, signal));
      const stream = can_ndjson_stream__WEBPACK_IMPORTED_MODULE_7___default()(body);
      const reader = stream.getReader();
      try {
        while (true) {
          // Read from the stream
          const {
            done,
            value
          } = yield (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_awaitAsyncGenerator_js__WEBPACK_IMPORTED_MODULE_1__["default"])(reader.read());
          // Exit if we're done
          if (done) return;
          // Else yield the chunk
          yield value;
        }
      } finally {
        reader.releaseLock();
      }
    })();
  }
  updateSyncStatus(options) {
    const updatedStatus = new _db_crud_SyncStatus__WEBPACK_IMPORTED_MODULE_8__.SyncStatus({
      connected: options.connected ?? this.syncStatus.connected,
      lastSyncedAt: options.lastSyncedAt ?? this.syncStatus.lastSyncedAt,
      dataFlow: {
        ...this.syncStatus.dataFlowStatus,
        ...options.dataFlow
      }
    });
    if (!this.syncStatus.isEqual(updatedStatus)) {
      this.syncStatus = updatedStatus;
      this.iterateListeners(cb => cb.statusChanged?.(updatedStatus));
    }
  }
  delayRetry() {
    var _this11 = this;
    return (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      return new Promise(resolve => setTimeout(resolve, _this11.options.retryDelayMs));
    })();
  }
}
//# sourceMappingURL=AbstractStreamingSyncImplementation.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/stream/streaming-sync-types.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/stream/streaming-sync-types.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isContinueCheckpointRequest: () => (/* binding */ isContinueCheckpointRequest),
/* harmony export */   isStreamingKeepalive: () => (/* binding */ isStreamingKeepalive),
/* harmony export */   isStreamingSyncCheckpoint: () => (/* binding */ isStreamingSyncCheckpoint),
/* harmony export */   isStreamingSyncCheckpointComplete: () => (/* binding */ isStreamingSyncCheckpointComplete),
/* harmony export */   isStreamingSyncCheckpointDiff: () => (/* binding */ isStreamingSyncCheckpointDiff),
/* harmony export */   isStreamingSyncData: () => (/* binding */ isStreamingSyncData),
/* harmony export */   isSyncNewCheckpointRequest: () => (/* binding */ isSyncNewCheckpointRequest)
/* harmony export */ });
function isStreamingSyncData(line) {
  return line.data != null;
}
function isStreamingKeepalive(line) {
  return line.token_expires_in != null;
}
function isStreamingSyncCheckpoint(line) {
  return line.checkpoint != null;
}
function isStreamingSyncCheckpointComplete(line) {
  return line.checkpoint_complete != null;
}
function isStreamingSyncCheckpointDiff(line) {
  return line.checkpoint_diff != null;
}
function isContinueCheckpointRequest(request) {
  return Array.isArray(request.buckets) && typeof request.checkpoint_token == 'string';
}
function isSyncNewCheckpointRequest(request) {
  return typeof request.request_checkpoint == 'object';
}
//# sourceMappingURL=streaming-sync-types.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/Column.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/db/Column.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Column: () => (/* binding */ Column),
/* harmony export */   ColumnType: () => (/* binding */ ColumnType)
/* harmony export */ });
// https://www.sqlite.org/lang_expr.html#castexpr
var ColumnType = /*#__PURE__*/function (ColumnType) {
  ColumnType["TEXT"] = "TEXT";
  ColumnType["INTEGER"] = "INTEGER";
  ColumnType["REAL"] = "REAL";
  return ColumnType;
}(ColumnType || {});
class Column {
  options;
  constructor(options) {
    this.options = options;
  }
  get name() {
    return this.options.name;
  }
  get type() {
    return this.options.type;
  }
  toJSON() {
    return {
      name: this.name,
      type: this.type
    };
  }
}
//# sourceMappingURL=Column.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/DBAdapter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/db/DBAdapter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RowUpdateType: () => (/* binding */ RowUpdateType),
/* harmony export */   extractTableUpdates: () => (/* binding */ extractTableUpdates),
/* harmony export */   isBatchedUpdateNotification: () => (/* binding */ isBatchedUpdateNotification)
/* harmony export */ });
/**
 * Set of generic interfaces to allow PowerSync compatibility with
 * different SQLite DB implementations.
 */
/**
 * Update table operation numbers from SQLite
 */
var RowUpdateType = /*#__PURE__*/function (RowUpdateType) {
  RowUpdateType[RowUpdateType["SQLITE_INSERT"] = 18] = "SQLITE_INSERT";
  RowUpdateType[RowUpdateType["SQLITE_DELETE"] = 9] = "SQLITE_DELETE";
  RowUpdateType[RowUpdateType["SQLITE_UPDATE"] = 23] = "SQLITE_UPDATE";
  return RowUpdateType;
}(RowUpdateType || {});
function isBatchedUpdateNotification(update) {
  return 'tables' in update;
}
function extractTableUpdates(update) {
  return isBatchedUpdateNotification(update) ? update.tables : [update.table];
}
//# sourceMappingURL=DBAdapter.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/crud/SyncStatus.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/db/crud/SyncStatus.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SyncStatus: () => (/* binding */ SyncStatus)
/* harmony export */ });
class SyncStatus {
  options;
  constructor(options) {
    this.options = options;
  }
  /**
   * true if currently connected.
   */
  get connected() {
    return this.options.connected ?? false;
  }
  /**
   *  Time that a last sync has fully completed, if any.
   *  Currently this is reset to null after a restart.
   */
  get lastSyncedAt() {
    return this.options.lastSyncedAt;
  }
  /**
   *  Upload/download status
   */
  get dataFlowStatus() {
    return this.options.dataFlow ?? {
      /**
       * true if actively downloading changes.
       * This is only true when {@link connected} is also true.
       */
      downloading: false,
      /**
       * true if uploading changes.
       */
      uploading: false
    };
  }
  isEqual(status) {
    return JSON.stringify(this.options) == JSON.stringify(status.options);
  }
  getMessage() {
    const dataFlow = this.dataFlowStatus;
    return `SyncStatus<connected: ${this.connected} lastSyncedAt: ${this.lastSyncedAt}. Downloading: ${dataFlow.downloading}. Uploading: ${dataFlow.uploading}`;
  }
  toJSON() {
    return {
      connected: this.connected,
      dataFlow: this.dataFlowStatus,
      lastSyncedAt: this.lastSyncedAt
    };
  }
}
//# sourceMappingURL=SyncStatus.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/crud/UploadQueueStatus.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/db/crud/UploadQueueStatus.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UploadQueueStats: () => (/* binding */ UploadQueueStats)
/* harmony export */ });
class UploadQueueStats {
  count;
  size;
  constructor(
  /**
   * Number of records in the upload queue.
   */
  count,
  /**
   * Size of the upload queue in bytes.
   */
  size = null) {
    this.count = count;
    this.size = size;
  }
  toString() {
    if (this.size == null) {
      return `UploadQueueStats<count:${this.count}>`;
    } else {
      return `UploadQueueStats<count: $count size: ${this.size / 1024}kB>`;
    }
  }
}
//# sourceMappingURL=UploadQueueStatus.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/schema/Index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/db/schema/Index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_INDEX_OPTIONS: () => (/* binding */ DEFAULT_INDEX_OPTIONS),
/* harmony export */   Index: () => (/* binding */ Index)
/* harmony export */ });
/* harmony import */ var _IndexedColumn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IndexedColumn */ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/schema/IndexedColumn.js");

const DEFAULT_INDEX_OPTIONS = {
  columns: []
};
class Index {
  options;
  static createAscending(options, columnNames) {
    return new Index({
      ...options,
      columns: columnNames.map(name => _IndexedColumn__WEBPACK_IMPORTED_MODULE_0__.IndexedColumn.createAscending(name))
    });
  }
  constructor(options) {
    this.options = options;
    this.options = {
      ...DEFAULT_INDEX_OPTIONS,
      ...options
    };
  }
  get name() {
    return this.options.name;
  }
  get columns() {
    return this.options.columns ?? [];
  }
  toJSON(table) {
    return {
      name: this.name,
      columns: this.columns.map(c => c.toJSON(table))
    };
  }
}
//# sourceMappingURL=Index.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/schema/IndexedColumn.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/db/schema/IndexedColumn.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_INDEX_COLUMN_OPTIONS: () => (/* binding */ DEFAULT_INDEX_COLUMN_OPTIONS),
/* harmony export */   IndexedColumn: () => (/* binding */ IndexedColumn)
/* harmony export */ });
/* harmony import */ var _Column__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Column */ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/Column.js");

const DEFAULT_INDEX_COLUMN_OPTIONS = {
  ascending: true
};
class IndexedColumn {
  options;
  static createAscending(column) {
    return new IndexedColumn({
      name: column,
      ascending: true
    });
  }
  constructor(options) {
    this.options = {
      ...DEFAULT_INDEX_COLUMN_OPTIONS,
      ...options
    };
  }
  get name() {
    return this.options.name;
  }
  get ascending() {
    return this.options.ascending;
  }
  toJSON(table) {
    return {
      name: this.name,
      ascending: this.ascending,
      type: table.columns.find(column => column.name === this.name)?.type ?? _Column__WEBPACK_IMPORTED_MODULE_0__.ColumnType.TEXT
    };
  }
}
//# sourceMappingURL=IndexedColumn.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/schema/Schema.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/db/schema/Schema.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Schema: () => (/* binding */ Schema)
/* harmony export */ });
/* harmony import */ var _Table__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Table */ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/schema/Table.js");

/**
 * A schema is a collection of tables. It is used to define the structure of a database.
 */
class Schema {
  tables;
  /*
    Only available when constructing with mapped typed definition columns
  */
  types;
  props;
  constructor(tables) {
    this.tables = tables;
    if (Array.isArray(tables)) {
      this.tables = tables;
    } else {
      this.props = tables;
      this.tables = this.convertToClassicTables(this.props);
    }
  }
  validate() {
    for (const table of this.tables) {
      table.validate();
    }
  }
  toJSON() {
    return {
      tables: this.tables.map(t => t.toJSON())
    };
  }
  convertToClassicTables(props) {
    return Object.entries(props).map(([name, table]) => {
      return _Table__WEBPACK_IMPORTED_MODULE_0__.Table.createTable(name, table);
    });
  }
}
//# sourceMappingURL=Schema.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/schema/Table.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/db/schema/Table.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_TABLE_OPTIONS: () => (/* binding */ DEFAULT_TABLE_OPTIONS),
/* harmony export */   InvalidSQLCharacters: () => (/* binding */ InvalidSQLCharacters),
/* harmony export */   Table: () => (/* binding */ Table)
/* harmony export */ });
/* harmony import */ var _Column__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Column */ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/Column.js");

const DEFAULT_TABLE_OPTIONS = {
  indexes: [],
  insertOnly: false,
  localOnly: false
};
const InvalidSQLCharacters = /["'%,.#\s[\]]/;
class Table {
  options;
  static createLocalOnly(options) {
    return new Table({
      ...options,
      localOnly: true,
      insertOnly: false
    });
  }
  static createInsertOnly(options) {
    return new Table({
      ...options,
      localOnly: false,
      insertOnly: true
    });
  }
  static createTable(name, table) {
    return new Table({
      name,
      columns: Object.entries(table.columns).map(([name, col]) => new _Column__WEBPACK_IMPORTED_MODULE_0__.Column({
        name,
        type: col.type
      })),
      indexes: table.indexes,
      localOnly: table.options.localOnly,
      insertOnly: table.options.insertOnly,
      viewName: table.options.viewName
    });
  }
  constructor(options) {
    this.options = {
      ...DEFAULT_TABLE_OPTIONS,
      ...options
    };
  }
  get name() {
    return this.options.name;
  }
  get viewNameOverride() {
    return this.options.viewName;
  }
  get viewName() {
    return this.viewNameOverride ?? this.name;
  }
  get columns() {
    return this.options.columns;
  }
  get indexes() {
    return this.options.indexes ?? [];
  }
  get localOnly() {
    return this.options.localOnly ?? false;
  }
  get insertOnly() {
    return this.options.insertOnly ?? false;
  }
  get internalName() {
    if (this.options.localOnly) {
      return `ps_data_local__${this.name}`;
    }
    return `ps_data__${this.name}`;
  }
  get validName() {
    if (InvalidSQLCharacters.test(this.name)) {
      return false;
    }
    if (this.viewNameOverride != null && InvalidSQLCharacters.test(this.viewNameOverride)) {
      return false;
    }
    return true;
  }
  validate() {
    if (InvalidSQLCharacters.test(this.name)) {
      throw new Error(`Invalid characters in table name: ${this.name}`);
    }
    if (this.viewNameOverride && InvalidSQLCharacters.test(this.viewNameOverride)) {
      throw new Error(`Invalid characters in view name: ${this.viewNameOverride}`);
    }
    const columnNames = new Set();
    columnNames.add('id');
    for (const column of this.columns) {
      const {
        name: columnName
      } = column;
      if (column.name == 'id') {
        throw new Error(`${this.name}: id column is automatically added, custom id columns are not supported`);
      }
      if (columnNames.has(columnName)) {
        throw new Error(`Duplicate column ${columnName}`);
      }
      if (InvalidSQLCharacters.test(columnName)) {
        throw new Error(`Invalid characters in column name: $name.${column}`);
      }
      columnNames.add(columnName);
    }
    const indexNames = new Set();
    for (const index of this.indexes) {
      if (indexNames.has(index.name)) {
        throw new Error(`Duplicate index $name.${index}`);
      }
      if (InvalidSQLCharacters.test(index.name)) {
        throw new Error(`Invalid characters in index name: $name.${index}`);
      }
      for (const column of index.columns) {
        if (!columnNames.has(column.name)) {
          throw new Error(`Column ${column.name} not found for index ${index.name}`);
        }
      }
      indexNames.add(index.name);
    }
  }
  toJSON() {
    return {
      name: this.name,
      view_name: this.viewName,
      local_only: this.localOnly,
      insert_only: this.insertOnly,
      columns: this.columns.map(c => c.toJSON()),
      indexes: this.indexes.map(e => e.toJSON(this))
    };
  }
}
//# sourceMappingURL=Table.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/schema/TableV2.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/db/schema/TableV2.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TableV2: () => (/* binding */ TableV2),
/* harmony export */   column: () => (/* binding */ column)
/* harmony export */ });
/* harmony import */ var _Column__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Column */ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/Column.js");
/* harmony import */ var _Index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Index */ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/schema/Index.js");
/* harmony import */ var _IndexedColumn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IndexedColumn */ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/schema/IndexedColumn.js");



const text = {
  type: _Column__WEBPACK_IMPORTED_MODULE_0__.ColumnType.TEXT
};
const integer = {
  type: _Column__WEBPACK_IMPORTED_MODULE_0__.ColumnType.INTEGER
};
const real = {
  type: _Column__WEBPACK_IMPORTED_MODULE_0__.ColumnType.REAL
};
const column = {
  text,
  integer,
  real
};
/*
  Generate a new table from the columns and indexes
*/
class TableV2 {
  columns;
  options;
  indexes;
  constructor(columns, options = {}) {
    this.columns = columns;
    this.options = options;
    if (options?.indexes) {
      this.indexes = Object.entries(options.indexes).map(([name, columns]) => {
        if (name.startsWith('-')) {
          return new _Index__WEBPACK_IMPORTED_MODULE_1__.Index({
            name: name.substring(1),
            columns: columns.map(c => new _IndexedColumn__WEBPACK_IMPORTED_MODULE_2__.IndexedColumn({
              name: c,
              ascending: false
            }))
          });
        }
        return new _Index__WEBPACK_IMPORTED_MODULE_1__.Index({
          name: name,
          columns: columns.map(c => new _IndexedColumn__WEBPACK_IMPORTED_MODULE_2__.IndexedColumn({
            name: c,
            ascending: true
          }))
        });
      });
    }
  }
}
//# sourceMappingURL=TableV2.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractPowerSyncDatabase: () => (/* reexport safe */ _client_AbstractPowerSyncDatabase__WEBPACK_IMPORTED_MODULE_0__.AbstractPowerSyncDatabase),
/* harmony export */   AbstractPowerSyncDatabaseOpenFactory: () => (/* reexport safe */ _client_AbstractPowerSyncOpenFactory__WEBPACK_IMPORTED_MODULE_1__.AbstractPowerSyncDatabaseOpenFactory),
/* harmony export */   AbstractRemote: () => (/* reexport safe */ _client_sync_stream_AbstractRemote__WEBPACK_IMPORTED_MODULE_13__.AbstractRemote),
/* harmony export */   AbstractStreamingSyncImplementation: () => (/* reexport safe */ _client_sync_stream_AbstractStreamingSyncImplementation__WEBPACK_IMPORTED_MODULE_14__.AbstractStreamingSyncImplementation),
/* harmony export */   BaseObserver: () => (/* reexport safe */ _utils_BaseObserver__WEBPACK_IMPORTED_MODULE_25__.BaseObserver),
/* harmony export */   Column: () => (/* reexport safe */ _db_Column__WEBPACK_IMPORTED_MODULE_23__.Column),
/* harmony export */   ColumnType: () => (/* reexport safe */ _db_Column__WEBPACK_IMPORTED_MODULE_23__.ColumnType),
/* harmony export */   CrudBatch: () => (/* reexport safe */ _client_sync_bucket_CrudBatch__WEBPACK_IMPORTED_MODULE_7__.CrudBatch),
/* harmony export */   CrudEntry: () => (/* reexport safe */ _client_sync_bucket_CrudEntry__WEBPACK_IMPORTED_MODULE_5__.CrudEntry),
/* harmony export */   CrudTransaction: () => (/* reexport safe */ _client_sync_bucket_CrudTransaction__WEBPACK_IMPORTED_MODULE_8__.CrudTransaction),
/* harmony export */   DEFAULT_CRUD_UPLOAD_THROTTLE_MS: () => (/* reexport safe */ _client_sync_stream_AbstractStreamingSyncImplementation__WEBPACK_IMPORTED_MODULE_14__.DEFAULT_CRUD_UPLOAD_THROTTLE_MS),
/* harmony export */   DEFAULT_INDEX_COLUMN_OPTIONS: () => (/* reexport safe */ _db_schema_IndexedColumn__WEBPACK_IMPORTED_MODULE_21__.DEFAULT_INDEX_COLUMN_OPTIONS),
/* harmony export */   DEFAULT_INDEX_OPTIONS: () => (/* reexport safe */ _db_schema_Index__WEBPACK_IMPORTED_MODULE_20__.DEFAULT_INDEX_OPTIONS),
/* harmony export */   DEFAULT_LOCK_TIMEOUT_MS: () => (/* reexport safe */ _client_AbstractPowerSyncDatabase__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_LOCK_TIMEOUT_MS),
/* harmony export */   DEFAULT_POWERSYNC_CLOSE_OPTIONS: () => (/* reexport safe */ _client_AbstractPowerSyncDatabase__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_POWERSYNC_CLOSE_OPTIONS),
/* harmony export */   DEFAULT_POWERSYNC_DB_OPTIONS: () => (/* reexport safe */ _client_AbstractPowerSyncDatabase__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_POWERSYNC_DB_OPTIONS),
/* harmony export */   DEFAULT_REMOTE_LOGGER: () => (/* reexport safe */ _client_sync_stream_AbstractRemote__WEBPACK_IMPORTED_MODULE_13__.DEFAULT_REMOTE_LOGGER),
/* harmony export */   DEFAULT_STREAMING_SYNC_OPTIONS: () => (/* reexport safe */ _client_sync_stream_AbstractStreamingSyncImplementation__WEBPACK_IMPORTED_MODULE_14__.DEFAULT_STREAMING_SYNC_OPTIONS),
/* harmony export */   DEFAULT_TABLE_OPTIONS: () => (/* reexport safe */ _db_schema_Table__WEBPACK_IMPORTED_MODULE_19__.DEFAULT_TABLE_OPTIONS),
/* harmony export */   DEFAULT_WATCH_THROTTLE_MS: () => (/* reexport safe */ _client_AbstractPowerSyncDatabase__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_WATCH_THROTTLE_MS),
/* harmony export */   Index: () => (/* reexport safe */ _db_schema_Index__WEBPACK_IMPORTED_MODULE_20__.Index),
/* harmony export */   IndexedColumn: () => (/* reexport safe */ _db_schema_IndexedColumn__WEBPACK_IMPORTED_MODULE_21__.IndexedColumn),
/* harmony export */   InvalidSQLCharacters: () => (/* reexport safe */ _db_schema_Table__WEBPACK_IMPORTED_MODULE_19__.InvalidSQLCharacters),
/* harmony export */   LockType: () => (/* reexport safe */ _client_sync_stream_AbstractStreamingSyncImplementation__WEBPACK_IMPORTED_MODULE_14__.LockType),
/* harmony export */   MAX_OP_ID: () => (/* reexport safe */ _client_sync_bucket_SyncDataBucket__WEBPACK_IMPORTED_MODULE_10__.MAX_OP_ID),
/* harmony export */   OpType: () => (/* reexport safe */ _client_sync_bucket_OpType__WEBPACK_IMPORTED_MODULE_11__.OpType),
/* harmony export */   OpTypeEnum: () => (/* reexport safe */ _client_sync_bucket_OpType__WEBPACK_IMPORTED_MODULE_11__.OpTypeEnum),
/* harmony export */   OplogEntry: () => (/* reexport safe */ _client_sync_bucket_OplogEntry__WEBPACK_IMPORTED_MODULE_12__.OplogEntry),
/* harmony export */   PSInternalTable: () => (/* reexport safe */ _client_sync_bucket_BucketStorageAdapter__WEBPACK_IMPORTED_MODULE_4__.PSInternalTable),
/* harmony export */   RowUpdateType: () => (/* reexport safe */ _db_DBAdapter__WEBPACK_IMPORTED_MODULE_22__.RowUpdateType),
/* harmony export */   Schema: () => (/* reexport safe */ _db_schema_Schema__WEBPACK_IMPORTED_MODULE_18__.Schema),
/* harmony export */   SqliteBucketStorage: () => (/* reexport safe */ _client_sync_bucket_SqliteBucketStorage__WEBPACK_IMPORTED_MODULE_6__.SqliteBucketStorage),
/* harmony export */   SyncDataBatch: () => (/* reexport safe */ _client_sync_bucket_SyncDataBatch__WEBPACK_IMPORTED_MODULE_9__.SyncDataBatch),
/* harmony export */   SyncDataBucket: () => (/* reexport safe */ _client_sync_bucket_SyncDataBucket__WEBPACK_IMPORTED_MODULE_10__.SyncDataBucket),
/* harmony export */   SyncStatus: () => (/* reexport safe */ _db_crud_SyncStatus__WEBPACK_IMPORTED_MODULE_16__.SyncStatus),
/* harmony export */   Table: () => (/* reexport safe */ _db_schema_Table__WEBPACK_IMPORTED_MODULE_19__.Table),
/* harmony export */   TableV2: () => (/* reexport safe */ _db_schema_TableV2__WEBPACK_IMPORTED_MODULE_24__.TableV2),
/* harmony export */   UpdateType: () => (/* reexport safe */ _client_sync_bucket_CrudEntry__WEBPACK_IMPORTED_MODULE_5__.UpdateType),
/* harmony export */   UploadQueueStats: () => (/* reexport safe */ _db_crud_UploadQueueStatus__WEBPACK_IMPORTED_MODULE_17__.UploadQueueStats),
/* harmony export */   column: () => (/* reexport safe */ _db_schema_TableV2__WEBPACK_IMPORTED_MODULE_24__.column),
/* harmony export */   extractTableUpdates: () => (/* reexport safe */ _db_DBAdapter__WEBPACK_IMPORTED_MODULE_22__.extractTableUpdates),
/* harmony export */   isBatchedUpdateNotification: () => (/* reexport safe */ _db_DBAdapter__WEBPACK_IMPORTED_MODULE_22__.isBatchedUpdateNotification),
/* harmony export */   isContinueCheckpointRequest: () => (/* reexport safe */ _client_sync_stream_streaming_sync_types__WEBPACK_IMPORTED_MODULE_15__.isContinueCheckpointRequest),
/* harmony export */   isStreamingKeepalive: () => (/* reexport safe */ _client_sync_stream_streaming_sync_types__WEBPACK_IMPORTED_MODULE_15__.isStreamingKeepalive),
/* harmony export */   isStreamingSyncCheckpoint: () => (/* reexport safe */ _client_sync_stream_streaming_sync_types__WEBPACK_IMPORTED_MODULE_15__.isStreamingSyncCheckpoint),
/* harmony export */   isStreamingSyncCheckpointComplete: () => (/* reexport safe */ _client_sync_stream_streaming_sync_types__WEBPACK_IMPORTED_MODULE_15__.isStreamingSyncCheckpointComplete),
/* harmony export */   isStreamingSyncCheckpointDiff: () => (/* reexport safe */ _client_sync_stream_streaming_sync_types__WEBPACK_IMPORTED_MODULE_15__.isStreamingSyncCheckpointDiff),
/* harmony export */   isStreamingSyncData: () => (/* reexport safe */ _client_sync_stream_streaming_sync_types__WEBPACK_IMPORTED_MODULE_15__.isStreamingSyncData),
/* harmony export */   isSyncNewCheckpointRequest: () => (/* reexport safe */ _client_sync_stream_streaming_sync_types__WEBPACK_IMPORTED_MODULE_15__.isSyncNewCheckpointRequest),
/* harmony export */   quoteIdentifier: () => (/* reexport safe */ _utils_strings__WEBPACK_IMPORTED_MODULE_26__.quoteIdentifier),
/* harmony export */   quoteJsonPath: () => (/* reexport safe */ _utils_strings__WEBPACK_IMPORTED_MODULE_26__.quoteJsonPath),
/* harmony export */   quoteString: () => (/* reexport safe */ _utils_strings__WEBPACK_IMPORTED_MODULE_26__.quoteString)
/* harmony export */ });
/* harmony import */ var _client_AbstractPowerSyncDatabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client/AbstractPowerSyncDatabase */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/AbstractPowerSyncDatabase.js");
/* harmony import */ var _client_AbstractPowerSyncOpenFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client/AbstractPowerSyncOpenFactory */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/AbstractPowerSyncOpenFactory.js");
/* harmony import */ var _client_connection_PowerSyncBackendConnector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./client/connection/PowerSyncBackendConnector */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/connection/PowerSyncBackendConnector.js");
/* harmony import */ var _client_connection_PowerSyncCredentials__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./client/connection/PowerSyncCredentials */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/connection/PowerSyncCredentials.js");
/* harmony import */ var _client_sync_bucket_BucketStorageAdapter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./client/sync/bucket/BucketStorageAdapter */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/BucketStorageAdapter.js");
/* harmony import */ var _client_sync_bucket_CrudEntry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./client/sync/bucket/CrudEntry */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/CrudEntry.js");
/* harmony import */ var _client_sync_bucket_SqliteBucketStorage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./client/sync/bucket/SqliteBucketStorage */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/SqliteBucketStorage.js");
/* harmony import */ var _client_sync_bucket_CrudBatch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./client/sync/bucket/CrudBatch */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/CrudBatch.js");
/* harmony import */ var _client_sync_bucket_CrudTransaction__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./client/sync/bucket/CrudTransaction */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/CrudTransaction.js");
/* harmony import */ var _client_sync_bucket_SyncDataBatch__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./client/sync/bucket/SyncDataBatch */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/SyncDataBatch.js");
/* harmony import */ var _client_sync_bucket_SyncDataBucket__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./client/sync/bucket/SyncDataBucket */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/SyncDataBucket.js");
/* harmony import */ var _client_sync_bucket_OpType__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./client/sync/bucket/OpType */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/OpType.js");
/* harmony import */ var _client_sync_bucket_OplogEntry__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./client/sync/bucket/OplogEntry */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/bucket/OplogEntry.js");
/* harmony import */ var _client_sync_stream_AbstractRemote__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./client/sync/stream/AbstractRemote */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/stream/AbstractRemote.js");
/* harmony import */ var _client_sync_stream_AbstractStreamingSyncImplementation__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./client/sync/stream/AbstractStreamingSyncImplementation */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/stream/AbstractStreamingSyncImplementation.js");
/* harmony import */ var _client_sync_stream_streaming_sync_types__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./client/sync/stream/streaming-sync-types */ "./node_modules/@journeyapps/powersync-sdk-common/lib/client/sync/stream/streaming-sync-types.js");
/* harmony import */ var _db_crud_SyncStatus__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./db/crud/SyncStatus */ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/crud/SyncStatus.js");
/* harmony import */ var _db_crud_UploadQueueStatus__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./db/crud/UploadQueueStatus */ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/crud/UploadQueueStatus.js");
/* harmony import */ var _db_schema_Schema__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./db/schema/Schema */ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/schema/Schema.js");
/* harmony import */ var _db_schema_Table__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./db/schema/Table */ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/schema/Table.js");
/* harmony import */ var _db_schema_Index__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./db/schema/Index */ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/schema/Index.js");
/* harmony import */ var _db_schema_IndexedColumn__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./db/schema/IndexedColumn */ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/schema/IndexedColumn.js");
/* harmony import */ var _db_DBAdapter__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./db/DBAdapter */ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/DBAdapter.js");
/* harmony import */ var _db_Column__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./db/Column */ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/Column.js");
/* harmony import */ var _db_schema_TableV2__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./db/schema/TableV2 */ "./node_modules/@journeyapps/powersync-sdk-common/lib/db/schema/TableV2.js");
/* harmony import */ var _utils_BaseObserver__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./utils/BaseObserver */ "./node_modules/@journeyapps/powersync-sdk-common/lib/utils/BaseObserver.js");
/* harmony import */ var _utils_strings__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./utils/strings */ "./node_modules/@journeyapps/powersync-sdk-common/lib/utils/strings.js");





























//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/utils/BaseObserver.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/utils/BaseObserver.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseObserver: () => (/* binding */ BaseObserver)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ "./node_modules/@journeyapps/powersync-sdk-common/node_modules/uuid/index.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uuid__WEBPACK_IMPORTED_MODULE_0__);

class BaseObserver {
  listeners;
  constructor() {
    this.listeners = {};
  }
  /**
   * Register a listener for updates to the PowerSync client.
   */
  registerListener(listener) {
    const id = (0,uuid__WEBPACK_IMPORTED_MODULE_0__.v4)();
    this.listeners[id] = listener;
    return () => {
      delete this.listeners[id];
    };
  }
  iterateListeners(cb) {
    for (const i in this.listeners) {
      cb(this.listeners[i]);
    }
  }
}
//# sourceMappingURL=BaseObserver.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/utils/mutex.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/utils/mutex.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mutexRunExclusive: () => (/* binding */ mutexRunExclusive)
/* harmony export */ });
/* harmony import */ var C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");

/**
 * Wrapper for async-mutex runExclusive, which allows for a timeout on each exclusive lock.
 */
function mutexRunExclusive(_x, _x2, _x3) {
  return _mutexRunExclusive.apply(this, arguments);
}
//# sourceMappingURL=mutex.js.map
function _mutexRunExclusive() {
  _mutexRunExclusive = (0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (mutex, callback, options) {
    return new Promise((resolve, reject) => {
      const timeout = options?.timeoutMs;
      let timedOut = false;
      const timeoutId = timeout ? setTimeout(() => {
        timedOut = true;
        reject(new Error('Timeout waiting for lock'));
      }, timeout) : undefined;
      mutex.runExclusive( /*#__PURE__*/(0,C_Projects_Todo_List_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (timedOut) return;
        try {
          resolve(yield callback());
        } catch (ex) {
          reject(ex);
        }
      }));
    });
  });
  return _mutexRunExclusive.apply(this, arguments);
}

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/lib/utils/strings.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/lib/utils/strings.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   quoteIdentifier: () => (/* binding */ quoteIdentifier),
/* harmony export */   quoteJsonPath: () => (/* binding */ quoteJsonPath),
/* harmony export */   quoteString: () => (/* binding */ quoteString)
/* harmony export */ });
function quoteString(s) {
  return `'${s.replaceAll("'", "''")}'`;
}
function quoteJsonPath(path) {
  return quoteString(`$.${path}`);
}
function quoteIdentifier(s) {
  return `"${s.replaceAll('"', '""')}"`;
}
//# sourceMappingURL=strings.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/node_modules/uuid/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/node_modules/uuid/index.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var v1 = __webpack_require__(/*! ./v1 */ "./node_modules/@journeyapps/powersync-sdk-common/node_modules/uuid/v1.js");
var v4 = __webpack_require__(/*! ./v4 */ "./node_modules/@journeyapps/powersync-sdk-common/node_modules/uuid/v4.js");
var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;
module.exports = uuid;

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/node_modules/uuid/lib/bytesToUuid.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/node_modules/uuid/lib/bytesToUuid.js ***!
  \*********************************************************************************************/
/***/ ((module) => {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}
function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');
}
module.exports = bytesToUuid;

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/node_modules/uuid/lib/rng-browser.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/node_modules/uuid/lib/rng-browser.js ***!
  \*********************************************************************************************/
/***/ ((module) => {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);
if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);
  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }
    return rnds;
  };
}

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/node_modules/uuid/v1.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/node_modules/uuid/v1.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/@journeyapps/powersync-sdk-common/node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/@journeyapps/powersync-sdk-common/node_modules/uuid/lib/bytesToUuid.js");

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf ? buf : bytesToUuid(b);
}
module.exports = v1;

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-common/node_modules/uuid/v4.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-common/node_modules/uuid/v4.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/@journeyapps/powersync-sdk-common/node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/@journeyapps/powersync-sdk-common/node_modules/uuid/lib/bytesToUuid.js");
function v4(options, buf, offset) {
  var i = buf && offset || 0;
  if (typeof options == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }
  return buf || bytesToUuid(rnds);
}
module.exports = v4;

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-web/lib/src/db/adapters/wa-sqlite/WASQLiteDBAdapter.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-web/lib/src/db/adapters/wa-sqlite/WASQLiteDBAdapter.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WASQLiteDBAdapter: () => (/* binding */ WASQLiteDBAdapter)
/* harmony export */ });
/* harmony import */ var _journeyapps_powersync_sdk_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @journeyapps/powersync-sdk-common */ "./node_modules/@journeyapps/powersync-sdk-common/lib/index.js");
/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! comlink */ "./node_modules/comlink/dist/esm/comlink.mjs");
/* harmony import */ var js_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-logger */ "./node_modules/js-logger/src/logger.js");
/* harmony import */ var js_logger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(js_logger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _worker_db_open_worker_database__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../worker/db/open-worker-database */ "./node_modules/@journeyapps/powersync-sdk-web/lib/src/worker/db/open-worker-database.js");
var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};




/**
 * Adapter for WA-SQLite
 */
class WASQLiteDBAdapter extends _journeyapps_powersync_sdk_common__WEBPACK_IMPORTED_MODULE_0__.BaseObserver {
  constructor(options) {
    super();
    this.options = options;
    /**
     * Wraps the worker execute function, awaiting for it to be available
     */
    this._execute = (sql, bindings) => __awaiter(this, void 0, void 0, function* () {
      yield this.initialized;
      const result = yield this.workerMethods.execute(sql, bindings);
      return Object.assign(Object.assign({}, result), {
        rows: Object.assign(Object.assign({}, result.rows), {
          item: idx => result.rows._array[idx]
        })
      });
    });
    this.logger = js_logger__WEBPACK_IMPORTED_MODULE_1___default().get('WASQLite');
    this.dbGetHelpers = null;
    this.workerMethods = null;
    this.initialized = this.init();
    this.dbGetHelpers = this.generateDBHelpers({
      execute: this._execute.bind(this)
    });
  }
  get name() {
    return this.options.dbFilename;
  }
  get flags() {
    var _a;
    return (_a = this.options.flags) !== null && _a !== void 0 ? _a : {};
  }
  getWorker() {}
  init() {
    return __awaiter(this, void 0, void 0, function* () {
      const {
        enableMultiTabs
      } = this.flags;
      if (!enableMultiTabs) {
        this.logger.warn('Multiple tabs are not enabled in this browser');
      }
      const dbOpener = this.options.workerPort ? comlink__WEBPACK_IMPORTED_MODULE_3__.wrap(this.options.workerPort) : (0,_worker_db_open_worker_database__WEBPACK_IMPORTED_MODULE_2__.getWorkerDatabaseOpener)(this.options.dbFilename, enableMultiTabs);
      this.workerMethods = yield dbOpener(this.options.dbFilename);
      this.workerMethods.registerOnTableChange(comlink__WEBPACK_IMPORTED_MODULE_3__.proxy((opType, tableName, rowId) => {
        this.iterateListeners(cb => {
          var _a;
          return (_a = cb.tablesUpdated) === null || _a === void 0 ? void 0 : _a.call(cb, {
            opType,
            table: tableName,
            rowId
          });
        });
      }));
    });
  }
  execute(query, params) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.writeLock(ctx => ctx.execute(query, params));
    });
  }
  /**
   * Attempts to close the connection.
   * Shared workers might not actually close the connection if other
   * tabs are still using it.
   */
  close() {
    var _a, _b;
    (_b = (_a = this.workerMethods) === null || _a === void 0 ? void 0 : _a.close) === null || _b === void 0 ? void 0 : _b.call(_a);
  }
  getAll(sql, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.initialized;
      return this.dbGetHelpers.getAll(sql, parameters);
    });
  }
  getOptional(sql, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.initialized;
      return this.dbGetHelpers.getOptional(sql, parameters);
    });
  }
  get(sql, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.initialized;
      return this.dbGetHelpers.get(sql, parameters);
    });
  }
  readLock(fn, options) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.initialized;
      return this.acquireLock(() => __awaiter(this, void 0, void 0, function* () {
        return fn(this.generateDBHelpers({
          execute: this._execute
        }));
      }));
    });
  }
  writeLock(fn, options) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.initialized;
      return this.acquireLock(() => __awaiter(this, void 0, void 0, function* () {
        return fn(this.generateDBHelpers({
          execute: this._execute
        }));
      }));
    });
  }
  acquireLock(callback) {
    return navigator.locks.request(`db-lock-${this.options.dbFilename}`, callback);
  }
  readTransaction(fn, options) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.readLock(this.wrapTransaction(fn));
    });
  }
  writeTransaction(fn, options) {
    return this.writeLock(this.wrapTransaction(fn));
  }
  /**
   * Wraps a lock context into a transaction context
   */
  wrapTransaction(cb) {
    return tx => __awaiter(this, void 0, void 0, function* () {
      yield this._execute('BEGIN TRANSACTION');
      let finalized = false;
      const commit = () => __awaiter(this, void 0, void 0, function* () {
        if (finalized) {
          return {
            rowsAffected: 0
          };
        }
        finalized = true;
        return this._execute('COMMIT');
      });
      const rollback = () => {
        finalized = true;
        return this._execute('ROLLBACK');
      };
      try {
        const result = yield cb(Object.assign(Object.assign({}, tx), {
          commit,
          rollback
        }));
        if (!finalized) {
          yield commit();
        }
        return result;
      } catch (ex) {
        this.logger.debug('Caught ex in transaction', ex);
        yield rollback();
        throw ex;
      }
    });
  }
  generateDBHelpers(tx) {
    return Object.assign(Object.assign({}, tx), {
      /**
       *  Execute a read-only query and return results
       */
      getAll(sql, parameters) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          const res = yield tx.execute(sql, parameters);
          return (_b = (_a = res.rows) === null || _a === void 0 ? void 0 : _a._array) !== null && _b !== void 0 ? _b : [];
        });
      },
      /**
       * Execute a read-only query and return the first result, or null if the ResultSet is empty.
       */
      getOptional(sql, parameters) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          const res = yield tx.execute(sql, parameters);
          return (_b = (_a = res.rows) === null || _a === void 0 ? void 0 : _a.item(0)) !== null && _b !== void 0 ? _b : null;
        });
      },
      /**
       * Execute a read-only query and return the first result, error if the ResultSet is empty.
       */
      get(sql, parameters) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const res = yield tx.execute(sql, parameters);
          const first = (_a = res.rows) === null || _a === void 0 ? void 0 : _a.item(0);
          if (!first) {
            throw new Error('Result set is empty');
          }
          return first;
        });
      }
    });
  }
}
//# sourceMappingURL=WASQLiteDBAdapter.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-web/lib/src/db/sync/WebRemote.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-web/lib/src/db/sync/WebRemote.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebRemote: () => (/* binding */ WebRemote)
/* harmony export */ });
/* harmony import */ var _journeyapps_powersync_sdk_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @journeyapps/powersync-sdk-common */ "./node_modules/@journeyapps/powersync-sdk-common/lib/index.js");
var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class WebRemote extends _journeyapps_powersync_sdk_common__WEBPACK_IMPORTED_MODULE_0__.AbstractRemote {
  post(path, data, headers = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const request = yield this.buildRequest(path);
      const res = yield fetch(request.url, {
        method: 'POST',
        headers: Object.assign(Object.assign({}, headers), request.headers),
        body: JSON.stringify(data)
      });
      if (!res.ok) {
        throw new Error(`Received ${res.status} - ${res.statusText} when posting to ${path}: ${yield res.text()}}`);
      }
      return res.json();
    });
  }
  get(path, headers) {
    return __awaiter(this, void 0, void 0, function* () {
      const request = yield this.buildRequest(path);
      const res = yield fetch(request.url, {
        method: 'GET',
        headers: Object.assign(Object.assign({}, headers), request.headers)
      });
      if (!res.ok) {
        throw new Error(`Received ${res.status} - ${res.statusText} when getting from ${path}: ${yield res.text()}}`);
      }
      return res.json();
    });
  }
  postStreaming(path, data, headers = {}, signal) {
    return __awaiter(this, void 0, void 0, function* () {
      const request = yield this.buildRequest(path);
      const res = yield fetch(request.url, {
        method: 'POST',
        headers: Object.assign(Object.assign({}, headers), request.headers),
        body: JSON.stringify(data),
        signal,
        cache: 'no-store'
      });
      if (!res.ok || !res.body) {
        const text = yield res.text();
        console.error(`Could not POST streaming to ${path} - ${res.status} - ${res.statusText}: ${text}`);
        const error = new Error(`HTTP ${res.statusText}: ${text}`);
        error.status = res.status;
        throw error;
      }
      /**
       * The can-ndjson-stream does not handle aborted streams well on web.
       * This will intercept the readable stream and close the stream if
       * aborted.
       */
      const reader = res.body.getReader();
      const outputStream = new ReadableStream({
        start(controller) {
          return processStream();
          function processStream() {
            return __awaiter(this, void 0, void 0, function* () {
              if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                controller.close();
              }
              try {
                const {
                  done,
                  value
                } = yield reader.read();
                // When no more data needs to be consumed, close the stream
                if (done) {
                  controller.close();
                  return;
                }
                // Enqueue the next data chunk into our target stream
                controller.enqueue(value);
                return processStream();
              } catch (ex) {
                controller.close();
              }
            });
          }
        }
      });
      // Create a new response out of the intercepted stream
      return new Response(outputStream).body;
    });
  }
}
//# sourceMappingURL=WebRemote.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-web/lib/src/db/sync/WebStreamingSyncImplementation.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-web/lib/src/db/sync/WebStreamingSyncImplementation.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebStreamingSyncImplementation: () => (/* binding */ WebStreamingSyncImplementation)
/* harmony export */ });
/* harmony import */ var _journeyapps_powersync_sdk_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @journeyapps/powersync-sdk-common */ "./node_modules/@journeyapps/powersync-sdk-common/lib/index.js");

class WebStreamingSyncImplementation extends _journeyapps_powersync_sdk_common__WEBPACK_IMPORTED_MODULE_0__.AbstractStreamingSyncImplementation {
  constructor(options) {
    // Super will store and provide default values for options
    super(options);
  }
  get webOptions() {
    return this.options;
  }
  obtainLock(lockOptions) {
    const identifier = `streaming-sync-${lockOptions.type}-${this.webOptions.identifier}`;
    lockOptions.type == _journeyapps_powersync_sdk_common__WEBPACK_IMPORTED_MODULE_0__.LockType.SYNC && console.debug('requesting lock for ', identifier);
    return navigator.locks.request(identifier, {
      signal: lockOptions.signal
    }, lockOptions.callback);
  }
}
//# sourceMappingURL=WebStreamingSyncImplementation.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-web/lib/src/worker/db/open-worker-database.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-web/lib/src/worker/db/open-worker-database.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getWorkerDatabaseOpener: () => (/* binding */ getWorkerDatabaseOpener),
/* harmony export */   openWorkerDatabasePort: () => (/* binding */ openWorkerDatabasePort)
/* harmony export */ });
/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! comlink */ "./node_modules/comlink/dist/esm/comlink.mjs");

/**
 * Opens a shared or dedicated worker which exposes opening of database connections
 */
function openWorkerDatabasePort(workerIdentifier, multipleTabs = true) {
  /**
   *  Webpack V5 can bundle the worker automatically if the full Worker constructor syntax is used
   *  https://webpack.js.org/guides/web-workers/
   *  This enables multi tab support by default, but falls back if SharedWorker is not available
   *  (in the case of Android)
   */
  return multipleTabs ? new SharedWorker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u("node_modules_journeyapps_powersync-sdk-web_lib_src_worker_db_SharedWASQLiteDB_worker_js"), __webpack_require__.b), {
    /* @vite-ignore */
    name: `shared-DB-worker-${workerIdentifier}`,
    type: undefined
  }).port : new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u("node_modules_journeyapps_powersync-sdk-web_lib_src_worker_db_WASQLiteDB_worker_js"), __webpack_require__.b), {
    /* @vite-ignore */
    name: `DB-worker-${workerIdentifier}`,
    type: undefined
  });
}
/**
 * @returns A function which allows for opening database connections inside
 * a worker.
 */
function getWorkerDatabaseOpener(workerIdentifier, multipleTabs = true) {
  return comlink__WEBPACK_IMPORTED_MODULE_0__.wrap(openWorkerDatabasePort(workerIdentifier, multipleTabs));
}
//# sourceMappingURL=open-worker-database.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-web/lib/src/worker/sync/BroadcastLogger.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-web/lib/src/worker/sync/BroadcastLogger.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BroadcastLogger: () => (/* binding */ BroadcastLogger)
/* harmony export */ });
/* harmony import */ var js_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-logger */ "./node_modules/js-logger/src/logger.js");
/* harmony import */ var js_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_logger__WEBPACK_IMPORTED_MODULE_0__);

/**
 * Broadcasts logs to all clients
 */
class BroadcastLogger {
  constructor(clients) {
    this.clients = clients;
    this.TRACE = (js_logger__WEBPACK_IMPORTED_MODULE_0___default().TRACE);
    this.DEBUG = (js_logger__WEBPACK_IMPORTED_MODULE_0___default().DEBUG);
    this.INFO = (js_logger__WEBPACK_IMPORTED_MODULE_0___default().INFO);
    this.TIME = (js_logger__WEBPACK_IMPORTED_MODULE_0___default().TIME);
    this.WARN = (js_logger__WEBPACK_IMPORTED_MODULE_0___default().WARN);
    this.ERROR = (js_logger__WEBPACK_IMPORTED_MODULE_0___default().ERROR);
    this.OFF = (js_logger__WEBPACK_IMPORTED_MODULE_0___default().OFF);
  }
  trace(...x) {
    console.trace(...x);
    this.clients.forEach(p => p.clientProvider.trace(...x));
  }
  debug(...x) {
    console.debug(...x);
    this.clients.forEach(p => p.clientProvider.debug(...x));
  }
  info(...x) {
    console.info(...x);
    this.clients.forEach(p => p.clientProvider.info(...x));
  }
  log(...x) {
    console.log(...x);
    this.sanitizeArgs(x, params => this.clients.forEach(p => p.clientProvider.log(...params)));
  }
  warn(...x) {
    console.warn(...x);
    this.sanitizeArgs(x, params => this.clients.forEach(p => p.clientProvider.warn(...params)));
  }
  error(...x) {
    console.error(...x);
    this.sanitizeArgs(x, params => this.clients.forEach(p => p.clientProvider.error(...params)));
  }
  time(label) {
    console.time(label);
    this.clients.forEach(p => p.clientProvider.time(label));
  }
  timeEnd(label) {
    console.timeEnd(label);
    this.clients.forEach(p => p.clientProvider.timeEnd(label));
  }
  setLevel(level) {
    // Levels are not adjustable on this level.
  }
  getLevel() {
    // Levels are not adjustable on this level.
    return (js_logger__WEBPACK_IMPORTED_MODULE_0___default().INFO);
  }
  enabledFor(level) {
    // Levels are not adjustable on this level.
    return true;
  }
  /**
   * Guards against any logging errors.
   * We don't want a logging exception to cause further issues upstream
   */
  sanitizeArgs(x, handler) {
    const sanitizedParams = x.map(param => {
      try {
        // Try and clone here first. If it fails it won't be passable over a MessagePort
        return structuredClone(x);
      } catch (ex) {
        console.error(ex);
        return 'Could not serialize log params. Check shared worker logs for more details.';
      }
    });
    return handler(...sanitizedParams);
  }
}
//# sourceMappingURL=BroadcastLogger.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-web/lib/src/worker/sync/SharedSyncImplementation.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-web/lib/src/worker/sync/SharedSyncImplementation.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SharedSyncClientEvent: () => (/* binding */ SharedSyncClientEvent),
/* harmony export */   SharedSyncImplementation: () => (/* binding */ SharedSyncImplementation)
/* harmony export */ });
/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! comlink */ "./node_modules/comlink/dist/esm/comlink.mjs");
/* harmony import */ var _journeyapps_powersync_sdk_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @journeyapps/powersync-sdk-common */ "./node_modules/@journeyapps/powersync-sdk-common/lib/index.js");
/* harmony import */ var _db_sync_WebStreamingSyncImplementation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../db/sync/WebStreamingSyncImplementation */ "./node_modules/@journeyapps/powersync-sdk-web/lib/src/db/sync/WebStreamingSyncImplementation.js");
/* harmony import */ var async_mutex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! async-mutex */ "./node_modules/async-mutex/index.mjs");
/* harmony import */ var _db_sync_WebRemote__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../db/sync/WebRemote */ "./node_modules/@journeyapps/powersync-sdk-web/lib/src/db/sync/WebRemote.js");
/* harmony import */ var _db_adapters_wa_sqlite_WASQLiteDBAdapter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../db/adapters/wa-sqlite/WASQLiteDBAdapter */ "./node_modules/@journeyapps/powersync-sdk-web/lib/src/db/adapters/wa-sqlite/WASQLiteDBAdapter.js");
/* harmony import */ var _BroadcastLogger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./BroadcastLogger */ "./node_modules/@journeyapps/powersync-sdk-web/lib/src/worker/sync/BroadcastLogger.js");
var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};







/**
 * Manual message events for shared sync clients
 */
var SharedSyncClientEvent = /*#__PURE__*/function (SharedSyncClientEvent) {
  /**
   * This client requests the shared sync manager should
   * close it's connection to the client.
   */
  SharedSyncClientEvent["CLOSE_CLIENT"] = "close-client";
  return SharedSyncClientEvent;
}(SharedSyncClientEvent || {});
/**
 * Shared sync implementation which runs inside a shared webworker
 */
class SharedSyncImplementation extends _journeyapps_powersync_sdk_common__WEBPACK_IMPORTED_MODULE_0__.BaseObserver {
  constructor() {
    super();
    this.ports = [];
    this.isInitialized = new Promise(resolve => {
      const callback = this.registerListener({
        initialized: () => {
          resolve();
          callback === null || callback === void 0 ? void 0 : callback();
        }
      });
    });
    this.syncStatus = new _journeyapps_powersync_sdk_common__WEBPACK_IMPORTED_MODULE_0__.SyncStatus({});
    this.broadCastLogger = new _BroadcastLogger__WEBPACK_IMPORTED_MODULE_5__.BroadcastLogger(this.ports);
  }
  waitForStatus(status) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.waitForReady();
      return this.syncStreamClient.waitForStatus(status);
    });
  }
  get lastSyncedAt() {
    var _a;
    return (_a = this.syncStreamClient) === null || _a === void 0 ? void 0 : _a.lastSyncedAt;
  }
  get isConnected() {
    var _a, _b;
    return (_b = (_a = this.syncStreamClient) === null || _a === void 0 ? void 0 : _a.isConnected) !== null && _b !== void 0 ? _b : false;
  }
  waitForReady() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.isInitialized;
    });
  }
  /**
   * Configures the DBAdapter connection and a streaming sync client.
   */
  init(dbWorkerPort, params) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.syncStreamClient) {
        // Cannot modify already existing sync implementation
        return;
      }
      this.syncStreamClient = new _db_sync_WebStreamingSyncImplementation__WEBPACK_IMPORTED_MODULE_1__.WebStreamingSyncImplementation(Object.assign(Object.assign({
        adapter: new _journeyapps_powersync_sdk_common__WEBPACK_IMPORTED_MODULE_0__.SqliteBucketStorage(new _db_adapters_wa_sqlite_WASQLiteDBAdapter__WEBPACK_IMPORTED_MODULE_4__.WASQLiteDBAdapter({
          dbFilename: params.dbName,
          workerPort: dbWorkerPort,
          flags: {
            enableMultiTabs: true
          },
          logger: this.broadCastLogger
        }), new async_mutex__WEBPACK_IMPORTED_MODULE_2__.Mutex(), this.broadCastLogger),
        remote: new _db_sync_WebRemote__WEBPACK_IMPORTED_MODULE_3__.WebRemote({
          fetchCredentials: () => __awaiter(this, void 0, void 0, function* () {
            const lastPort = this.ports[this.ports.length - 1];
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
              const abortController = new AbortController();
              this.fetchCredentialsController = {
                controller: abortController,
                activePort: lastPort
              };
              abortController.signal.onabort = reject;
              try {
                resolve(yield lastPort.clientProvider.fetchCredentials());
              } catch (ex) {
                reject(ex);
              } finally {
                this.fetchCredentialsController = undefined;
              }
            }));
          })
        }),
        uploadCrud: () => __awaiter(this, void 0, void 0, function* () {
          const lastPort = this.ports[this.ports.length - 1];
          return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const abortController = new AbortController();
            this.uploadDataController = {
              controller: abortController,
              activePort: lastPort
            };
            // Resolving will make it retry
            abortController.signal.onabort = () => resolve();
            try {
              resolve(yield lastPort.clientProvider.uploadCrud());
            } catch (ex) {
              reject(ex);
            } finally {
              this.uploadDataController = undefined;
            }
          }));
        })
      }, params.streamOptions), {
        // Logger cannot be transferred just yet
        logger: this.broadCastLogger
      }));
      this.syncStreamClient.registerListener({
        statusChanged: status => {
          this.updateAllStatuses(status.toJSON());
        }
      });
      this.iterateListeners(l => {
        var _a;
        return (_a = l.initialized) === null || _a === void 0 ? void 0 : _a.call(l);
      });
    });
  }
  dispose() {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
      yield this.waitForReady();
      (_a = this.statusListener) === null || _a === void 0 ? void 0 : _a.call(this);
      return (_b = this.syncStreamClient) === null || _b === void 0 ? void 0 : _b.dispose();
    });
  }
  /**
   * Connects to the PowerSync backend instance.
   * Multiple tabs can safely call this in their initialization.
   * The connection will simply be reconnected whenever a new tab
   * connects.
   */
  connect() {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      yield this.waitForReady();
      this.disconnect();
      this.abortController = new AbortController();
      (_a = this.syncStreamClient) === null || _a === void 0 ? void 0 : _a.streamingSync(this.abortController.signal);
    });
  }
  disconnect() {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort('Disconnected');
      this.updateAllStatuses({
        connected: false
      });
    });
  }
  /**
   * Adds a new client tab's message port to the list of connected ports
   */
  addPort(port) {
    var _a;
    const portProvider = {
      port,
      clientProvider: comlink__WEBPACK_IMPORTED_MODULE_6__.wrap(port)
    };
    this.ports.push(portProvider);
    // Give the newly connected client the latest status
    const status = (_a = this.syncStreamClient) === null || _a === void 0 ? void 0 : _a.syncStatus;
    if (status) {
      portProvider.clientProvider.statusChanged(status.toJSON());
    }
  }
  /**
   * Removes a message port client from this manager's managed
   * clients.
   */
  removePort(port) {
    const index = this.ports.findIndex(p => p.port == port);
    if (index < 0) {
      console.warn(`Could not remove port ${port} since it is not present in active ports.`);
      return;
    }
    const trackedPort = this.ports[index];
    // Release proxy
    trackedPort.clientProvider[comlink__WEBPACK_IMPORTED_MODULE_6__.releaseProxy]();
    this.ports.splice(index, 1);
    /**
     * The port might currently be in use. Any active functions might
     * not resolve. Abort them here.
     */
    [this.fetchCredentialsController, this.uploadDataController].forEach(abortController => {
      if ((abortController === null || abortController === void 0 ? void 0 : abortController.activePort.port) == port) {
        abortController.controller.abort();
      }
    });
  }
  triggerCrudUpload() {
    this.waitForReady().then(() => {
      var _a;
      return (_a = this.syncStreamClient) === null || _a === void 0 ? void 0 : _a.triggerCrudUpload();
    });
  }
  obtainLock(lockOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.waitForReady();
      return this.syncStreamClient.obtainLock(lockOptions);
    });
  }
  hasCompletedSync() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.waitForReady();
      return this.syncStreamClient.hasCompletedSync();
    });
  }
  getWriteCheckpoint() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.waitForReady();
      return this.syncStreamClient.getWriteCheckpoint();
    });
  }
  /**
   * A method to update the all shared statuses for each
   * client.
   */
  updateAllStatuses(status) {
    this.syncStatus = new _journeyapps_powersync_sdk_common__WEBPACK_IMPORTED_MODULE_0__.SyncStatus(status);
    this.ports.forEach(p => p.clientProvider.statusChanged(status));
  }
  /**
   * A function only used for unit tests which updates the internal
   * sync stream client and all tab client's sync status
   */
  _testUpdateAllStatuses(status) {
    if (!this.syncStreamClient) {
      console.warn('no stream client has been initialized yet');
    }
    // Only assigning, don't call listeners for this test
    this.syncStreamClient.syncStatus = new _journeyapps_powersync_sdk_common__WEBPACK_IMPORTED_MODULE_0__.SyncStatus(status);
    this.updateAllStatuses(status);
  }
}
//# sourceMappingURL=SharedSyncImplementation.js.map

/***/ }),

/***/ "./node_modules/@journeyapps/powersync-sdk-web/lib/src/worker/sync/SharedSyncImplementation.worker.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@journeyapps/powersync-sdk-web/lib/src/worker/sync/SharedSyncImplementation.worker.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! comlink */ "./node_modules/comlink/dist/esm/comlink.mjs");
/* harmony import */ var _SharedSyncImplementation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SharedSyncImplementation */ "./node_modules/@journeyapps/powersync-sdk-web/lib/src/worker/sync/SharedSyncImplementation.js");
/* harmony import */ var js_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-logger */ "./node_modules/js-logger/src/logger.js");
/* harmony import */ var js_logger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(js_logger__WEBPACK_IMPORTED_MODULE_1__);



const _self = self;
js_logger__WEBPACK_IMPORTED_MODULE_1___default().useDefaults();
const sharedSyncImplementation = new _SharedSyncImplementation__WEBPACK_IMPORTED_MODULE_0__.SharedSyncImplementation();
_self.onconnect = function (event) {
  const port = event.ports[0];
  /**
   * Adds an extra listener which can remove this port
   * from the list of monitored ports.
   */
  port.addEventListener('message', event => {
    const payload = event.data;
    if ((payload === null || payload === void 0 ? void 0 : payload.event) == _SharedSyncImplementation__WEBPACK_IMPORTED_MODULE_0__.SharedSyncClientEvent.CLOSE_CLIENT) {
      console.log('closing shared for port', port);
      sharedSyncImplementation.removePort(port);
    }
  });
  comlink__WEBPACK_IMPORTED_MODULE_2__.expose(sharedSyncImplementation, port);
  sharedSyncImplementation.addPort(port);
};
//# sourceMappingURL=SharedSyncImplementation.worker.js.map

/***/ }),

/***/ "./node_modules/can-namespace/can-namespace.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-namespace/can-namespace.js ***!
  \*****************************************************/
/***/ ((module) => {

module.exports = {};

/***/ }),

/***/ "./node_modules/can-ndjson-stream/can-ndjson-stream.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-ndjson-stream/can-ndjson-stream.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*exported ndjsonStream*/
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var ndjsonStream = function (response) {
  // For cancellation
  var is_reader,
    cancellationRequest = false;
  return new ReadableStream({
    start: function (controller) {
      var reader = response.getReader();
      is_reader = reader;
      var decoder = new TextDecoder();
      var data_buf = "";
      reader.read().then(function processResult(result) {
        if (result.done) {
          if (cancellationRequest) {
            // Immediately exit
            return;
          }
          data_buf = data_buf.trim();
          if (data_buf.length !== 0) {
            try {
              var data_l = JSON.parse(data_buf);
              controller.enqueue(data_l);
            } catch (e) {
              controller.error(e);
              return;
            }
          }
          controller.close();
          return;
        }
        var data = decoder.decode(result.value, {
          stream: true
        });
        data_buf += data;
        var lines = data_buf.split("\n");
        for (var i = 0; i < lines.length - 1; ++i) {
          var l = lines[i].trim();
          if (l.length > 0) {
            try {
              var data_line = JSON.parse(l);
              controller.enqueue(data_line);
            } catch (e) {
              controller.error(e);
              cancellationRequest = true;
              reader.cancel();
              return;
            }
          }
        }
        data_buf = lines[lines.length - 1];
        return reader.read().then(processResult);
      });
    },
    cancel: function (reason) {
      console.log("Cancel registered due to ", reason);
      cancellationRequest = true;
      is_reader.cancel();
    }
  });
};
module.exports = namespace.ndjsonStream = ndjsonStream;

/***/ }),

/***/ "./node_modules/event-iterator/lib/dom.js":
/*!************************************************!*\
  !*** ./node_modules/event-iterator/lib/dom.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
const event_iterator_1 = __webpack_require__(/*! ./event-iterator */ "./node_modules/event-iterator/lib/event-iterator.js");
exports.EventIterator = event_iterator_1.EventIterator;
function subscribe(event, options, evOptions) {
  return new event_iterator_1.EventIterator(({
    push
  }) => {
    this.addEventListener(event, push, options);
    return () => this.removeEventListener(event, push, options);
  }, evOptions);
}
exports.subscribe = subscribe;
exports["default"] = event_iterator_1.EventIterator;

/***/ }),

/***/ "./node_modules/event-iterator/lib/event-iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/event-iterator/lib/event-iterator.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
class EventQueue {
  constructor() {
    this.pullQueue = [];
    this.pushQueue = [];
    this.eventHandlers = {};
    this.isPaused = false;
    this.isStopped = false;
  }
  push(value) {
    if (this.isStopped) return;
    const resolution = {
      value,
      done: false
    };
    if (this.pullQueue.length) {
      const placeholder = this.pullQueue.shift();
      if (placeholder) placeholder.resolve(resolution);
    } else {
      this.pushQueue.push(Promise.resolve(resolution));
      if (this.highWaterMark !== undefined && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {
        this.isPaused = true;
        if (this.eventHandlers.highWater) {
          this.eventHandlers.highWater();
        } else if (console) {
          console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
        }
      }
    }
  }
  stop() {
    if (this.isStopped) return;
    this.isStopped = true;
    this.remove();
    for (const placeholder of this.pullQueue) {
      placeholder.resolve({
        value: undefined,
        done: true
      });
    }
    this.pullQueue.length = 0;
  }
  fail(error) {
    if (this.isStopped) return;
    this.isStopped = true;
    this.remove();
    if (this.pullQueue.length) {
      for (const placeholder of this.pullQueue) {
        placeholder.reject(error);
      }
      this.pullQueue.length = 0;
    } else {
      const rejection = Promise.reject(error);
      /* Attach error handler to avoid leaking an unhandled promise rejection. */
      rejection.catch(() => {});
      this.pushQueue.push(rejection);
    }
  }
  remove() {
    Promise.resolve().then(() => {
      if (this.removeCallback) this.removeCallback();
    });
  }
  [Symbol.asyncIterator]() {
    return {
      next: value => {
        const result = this.pushQueue.shift();
        if (result) {
          if (this.lowWaterMark !== undefined && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {
            this.isPaused = false;
            if (this.eventHandlers.lowWater) {
              this.eventHandlers.lowWater();
            }
          }
          return result;
        } else if (this.isStopped) {
          return Promise.resolve({
            value: undefined,
            done: true
          });
        } else {
          return new Promise((resolve, reject) => {
            this.pullQueue.push({
              resolve,
              reject
            });
          });
        }
      },
      return: () => {
        this.isStopped = true;
        this.pushQueue.length = 0;
        this.remove();
        return Promise.resolve({
          value: undefined,
          done: true
        });
      }
    };
  }
}
class EventIterator {
  constructor(listen, {
    highWaterMark = 100,
    lowWaterMark = 1
  } = {}) {
    const queue = new EventQueue();
    queue.highWaterMark = highWaterMark;
    queue.lowWaterMark = lowWaterMark;
    queue.removeCallback = listen({
      push: value => queue.push(value),
      stop: () => queue.stop(),
      fail: error => queue.fail(error),
      on: (event, fn) => {
        queue.eventHandlers[event] = fn;
      }
    }) || (() => {});
    this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
    Object.freeze(this);
  }
}
exports.EventIterator = EventIterator;
exports["default"] = EventIterator;

/***/ }),

/***/ "./node_modules/js-logger/src/logger.js":
/*!**********************************************!*\
  !*** ./node_modules/js-logger/src/logger.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * js-logger - http://github.com/jonnyreeves/js-logger
 * Jonny Reeves, http://jonnyreeves.co.uk/
 * js-logger may be freely distributed under the MIT license.
 */
(function (global) {
  "use strict";

  // Top level module for the global, static logger instance.
  var Logger = {};

  // For those that are at home that are keeping score.
  Logger.VERSION = "1.6.1";

  // Function which handles all incoming log messages.
  var logHandler;

  // Map of ContextualLogger instances by name; used by Logger.get() to return the same named instance.
  var contextualLoggersByNameMap = {};

  // Polyfill for ES5's Function.bind.
  var bind = function (scope, func) {
    return function () {
      return func.apply(scope, arguments);
    };
  };

  // Super exciting object merger-matron 9000 adding another 100 bytes to your download.
  var merge = function () {
    var args = arguments,
      target = args[0],
      key,
      i;
    for (i = 1; i < args.length; i++) {
      for (key in args[i]) {
        if (!(key in target) && args[i].hasOwnProperty(key)) {
          target[key] = args[i][key];
        }
      }
    }
    return target;
  };

  // Helper to define a logging level object; helps with optimisation.
  var defineLogLevel = function (value, name) {
    return {
      value: value,
      name: name
    };
  };

  // Predefined logging levels.
  Logger.TRACE = defineLogLevel(1, 'TRACE');
  Logger.DEBUG = defineLogLevel(2, 'DEBUG');
  Logger.INFO = defineLogLevel(3, 'INFO');
  Logger.TIME = defineLogLevel(4, 'TIME');
  Logger.WARN = defineLogLevel(5, 'WARN');
  Logger.ERROR = defineLogLevel(8, 'ERROR');
  Logger.OFF = defineLogLevel(99, 'OFF');

  // Inner class which performs the bulk of the work; ContextualLogger instances can be configured independently
  // of each other.
  var ContextualLogger = function (defaultContext) {
    this.context = defaultContext;
    this.setLevel(defaultContext.filterLevel);
    this.log = this.info; // Convenience alias.
  };
  ContextualLogger.prototype = {
    // Changes the current logging level for the logging instance.
    setLevel: function (newLevel) {
      // Ensure the supplied Level object looks valid.
      if (newLevel && "value" in newLevel) {
        this.context.filterLevel = newLevel;
      }
    },
    // Gets the current logging level for the logging instance
    getLevel: function () {
      return this.context.filterLevel;
    },
    // Is the logger configured to output messages at the supplied level?
    enabledFor: function (lvl) {
      var filterLevel = this.context.filterLevel;
      return lvl.value >= filterLevel.value;
    },
    trace: function () {
      this.invoke(Logger.TRACE, arguments);
    },
    debug: function () {
      this.invoke(Logger.DEBUG, arguments);
    },
    info: function () {
      this.invoke(Logger.INFO, arguments);
    },
    warn: function () {
      this.invoke(Logger.WARN, arguments);
    },
    error: function () {
      this.invoke(Logger.ERROR, arguments);
    },
    time: function (label) {
      if (typeof label === 'string' && label.length > 0) {
        this.invoke(Logger.TIME, [label, 'start']);
      }
    },
    timeEnd: function (label) {
      if (typeof label === 'string' && label.length > 0) {
        this.invoke(Logger.TIME, [label, 'end']);
      }
    },
    // Invokes the logger callback if it's not being filtered.
    invoke: function (level, msgArgs) {
      if (logHandler && this.enabledFor(level)) {
        logHandler(msgArgs, merge({
          level: level
        }, this.context));
      }
    }
  };

  // Protected instance which all calls to the to level `Logger` module will be routed through.
  var globalLogger = new ContextualLogger({
    filterLevel: Logger.OFF
  });

  // Configure the global Logger instance.
  (function () {
    // Shortcut for optimisers.
    var L = Logger;
    L.enabledFor = bind(globalLogger, globalLogger.enabledFor);
    L.trace = bind(globalLogger, globalLogger.trace);
    L.debug = bind(globalLogger, globalLogger.debug);
    L.time = bind(globalLogger, globalLogger.time);
    L.timeEnd = bind(globalLogger, globalLogger.timeEnd);
    L.info = bind(globalLogger, globalLogger.info);
    L.warn = bind(globalLogger, globalLogger.warn);
    L.error = bind(globalLogger, globalLogger.error);

    // Don't forget the convenience alias!
    L.log = L.info;
  })();

  // Set the global logging handler.  The supplied function should expect two arguments, the first being an arguments
  // object with the supplied log messages and the second being a context object which contains a hash of stateful
  // parameters which the logging function can consume.
  Logger.setHandler = function (func) {
    logHandler = func;
  };

  // Sets the global logging filter level which applies to *all* previously registered, and future Logger instances.
  // (note that named loggers (retrieved via `Logger.get`) can be configured independently if required).
  Logger.setLevel = function (level) {
    // Set the globalLogger's level.
    globalLogger.setLevel(level);

    // Apply this level to all registered contextual loggers.
    for (var key in contextualLoggersByNameMap) {
      if (contextualLoggersByNameMap.hasOwnProperty(key)) {
        contextualLoggersByNameMap[key].setLevel(level);
      }
    }
  };

  // Gets the global logging filter level
  Logger.getLevel = function () {
    return globalLogger.getLevel();
  };

  // Retrieve a ContextualLogger instance.  Note that named loggers automatically inherit the global logger's level,
  // default context and log handler.
  Logger.get = function (name) {
    // All logger instances are cached so they can be configured ahead of use.
    return contextualLoggersByNameMap[name] || (contextualLoggersByNameMap[name] = new ContextualLogger(merge({
      name: name
    }, globalLogger.context)));
  };

  // CreateDefaultHandler returns a handler function which can be passed to `Logger.setHandler()` which will
  // write to the window's console object (if present); the optional options object can be used to customise the
  // formatter used to format each log message.
  Logger.createDefaultHandler = function (options) {
    options = options || {};
    options.formatter = options.formatter || function defaultMessageFormatter(messages, context) {
      // Prepend the logger's name to the log message for easy identification.
      if (context.name) {
        messages.unshift("[" + context.name + "]");
      }
    };

    // Map of timestamps by timer labels used to track `#time` and `#timeEnd()` invocations in environments
    // that don't offer a native console method.
    var timerStartTimeByLabelMap = {};

    // Support for IE8+ (and other, slightly more sane environments)
    var invokeConsoleMethod = function (hdlr, messages) {
      Function.prototype.apply.call(hdlr, console, messages);
    };

    // Check for the presence of a logger.
    if (typeof console === "undefined") {
      return function () {/* no console */};
    }
    return function (messages, context) {
      // Convert arguments object to Array.
      messages = Array.prototype.slice.call(messages);
      var hdlr = console.log;
      var timerLabel;
      if (context.level === Logger.TIME) {
        timerLabel = (context.name ? '[' + context.name + '] ' : '') + messages[0];
        if (messages[1] === 'start') {
          if (console.time) {
            console.time(timerLabel);
          } else {
            timerStartTimeByLabelMap[timerLabel] = new Date().getTime();
          }
        } else {
          if (console.timeEnd) {
            console.timeEnd(timerLabel);
          } else {
            invokeConsoleMethod(hdlr, [timerLabel + ': ' + (new Date().getTime() - timerStartTimeByLabelMap[timerLabel]) + 'ms']);
          }
        }
      } else {
        // Delegate through to custom warn/error loggers if present on the console.
        if (context.level === Logger.WARN && console.warn) {
          hdlr = console.warn;
        } else if (context.level === Logger.ERROR && console.error) {
          hdlr = console.error;
        } else if (context.level === Logger.INFO && console.info) {
          hdlr = console.info;
        } else if (context.level === Logger.DEBUG && console.debug) {
          hdlr = console.debug;
        } else if (context.level === Logger.TRACE && console.trace) {
          hdlr = console.trace;
        }
        options.formatter(messages, context);
        invokeConsoleMethod(hdlr, messages);
      }
    };
  };

  // Configure and example a Default implementation which writes to the `window.console` (if present).  The
  // `options` hash can be used to configure the default logLevel and provide a custom message formatter.
  Logger.useDefaults = function (options) {
    Logger.setLevel(options && options.defaultLevel || Logger.DEBUG);
    Logger.setHandler(Logger.createDefaultHandler(options));
  };

  // Createa an alias to useDefaults to avoid reaking a react-hooks rule.
  Logger.setDefaults = Logger.useDefaults;

  // Export to popular environments boilerplate.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (Logger),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this);

/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;
module.exports = Symbol;

/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
  getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
  objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
  undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
module.exports = baseGetTag;

/***/ }),

/***/ "./node_modules/lodash/_baseTrim.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseTrim.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var trimmedEndIndex = __webpack_require__(/*! ./_trimmedEndIndex */ "./node_modules/lodash/_trimmedEndIndex.js");

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
}
module.exports = baseTrim;

/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/***/ ((module) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
module.exports = freeGlobal;

/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
    tag = value[symToStringTag];
  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
module.exports = getRawTag;

/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}
module.exports = objectToString;

/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;

/***/ }),

/***/ "./node_modules/lodash/_trimmedEndIndex.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_trimmedEndIndex.js ***!
  \*************************************************/
/***/ ((module) => {

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}
module.exports = trimmedEndIndex;

/***/ }),

/***/ "./node_modules/lodash/debounce.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/debounce.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
  now = __webpack_require__(/*! ./now */ "./node_modules/lodash/now.js"),
  toNumber = __webpack_require__(/*! ./toNumber */ "./node_modules/lodash/toNumber.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
  nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
    lastThis,
    maxWait,
    result,
    timerId,
    lastCallTime,
    lastInvokeTime = 0,
    leading = false,
    maxing = false,
    trailing = true;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs,
      thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
      timeSinceLastInvoke = time - lastInvokeTime,
      timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
      timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }
  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }
  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(),
      isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
module.exports = debounce;

/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}
module.exports = isObject;

/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}
module.exports = isObjectLike;

/***/ }),

/***/ "./node_modules/lodash/isSymbol.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isSymbol.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
  isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}
module.exports = isSymbol;

/***/ }),

/***/ "./node_modules/lodash/now.js":
/*!************************************!*\
  !*** ./node_modules/lodash/now.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function () {
  return root.Date.now();
};
module.exports = now;

/***/ }),

/***/ "./node_modules/lodash/throttle.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/throttle.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var debounce = __webpack_require__(/*! ./debounce */ "./node_modules/lodash/debounce.js"),
  isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
    trailing = true;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}
module.exports = throttle;

/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTrim = __webpack_require__(/*! ./_baseTrim */ "./node_modules/lodash/_baseTrim.js"),
  isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
  isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
module.exports = toNumber;

/***/ }),

/***/ "./node_modules/async-mutex/index.mjs":
/*!********************************************!*\
  !*** ./node_modules/async-mutex/index.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E_ALREADY_LOCKED: () => (/* binding */ E_ALREADY_LOCKED),
/* harmony export */   E_CANCELED: () => (/* binding */ E_CANCELED),
/* harmony export */   E_TIMEOUT: () => (/* binding */ E_TIMEOUT),
/* harmony export */   Mutex: () => (/* binding */ Mutex),
/* harmony export */   Semaphore: () => (/* binding */ Semaphore),
/* harmony export */   tryAcquire: () => (/* binding */ tryAcquire),
/* harmony export */   withTimeout: () => (/* binding */ withTimeout)
/* harmony export */ });
const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');
const E_ALREADY_LOCKED = new Error('mutex already locked');
const E_CANCELED = new Error('request for lock canceled');
var __awaiter$2 =  false || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class Semaphore {
  constructor(_value, _cancelError = E_CANCELED) {
    this._value = _value;
    this._cancelError = _cancelError;
    this._weightedQueues = [];
    this._weightedWaiters = [];
  }
  acquire(weight = 1) {
    if (weight <= 0) throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve, reject) => {
      if (!this._weightedQueues[weight - 1]) this._weightedQueues[weight - 1] = [];
      this._weightedQueues[weight - 1].push({
        resolve,
        reject
      });
      this._dispatch();
    });
  }
  runExclusive(callback, weight = 1) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const [value, release] = yield this.acquire(weight);
      try {
        return yield callback(value);
      } finally {
        release();
      }
    });
  }
  waitForUnlock(weight = 1) {
    if (weight <= 0) throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise(resolve => {
      if (!this._weightedWaiters[weight - 1]) this._weightedWaiters[weight - 1] = [];
      this._weightedWaiters[weight - 1].push(resolve);
      this._dispatch();
    });
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(value) {
    this._value = value;
    this._dispatch();
  }
  release(weight = 1) {
    if (weight <= 0) throw new Error(`invalid weight ${weight}: must be positive`);
    this._value += weight;
    this._dispatch();
  }
  cancel() {
    this._weightedQueues.forEach(queue => queue.forEach(entry => entry.reject(this._cancelError)));
    this._weightedQueues = [];
  }
  _dispatch() {
    var _a;
    for (let weight = this._value; weight > 0; weight--) {
      const queueEntry = (_a = this._weightedQueues[weight - 1]) === null || _a === void 0 ? void 0 : _a.shift();
      if (!queueEntry) continue;
      const previousValue = this._value;
      const previousWeight = weight;
      this._value -= weight;
      weight = this._value + 1;
      queueEntry.resolve([previousValue, this._newReleaser(previousWeight)]);
    }
    this._drainUnlockWaiters();
  }
  _newReleaser(weight) {
    let called = false;
    return () => {
      if (called) return;
      called = true;
      this.release(weight);
    };
  }
  _drainUnlockWaiters() {
    for (let weight = this._value; weight > 0; weight--) {
      if (!this._weightedWaiters[weight - 1]) continue;
      this._weightedWaiters[weight - 1].forEach(waiter => waiter());
      this._weightedWaiters[weight - 1] = [];
    }
  }
}
var __awaiter$1 =  false || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class Mutex {
  constructor(cancelError) {
    this._semaphore = new Semaphore(1, cancelError);
  }
  acquire() {
    return __awaiter$1(this, void 0, void 0, function* () {
      const [, releaser] = yield this._semaphore.acquire();
      return releaser;
    });
  }
  runExclusive(callback) {
    return this._semaphore.runExclusive(() => callback());
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock() {
    return this._semaphore.waitForUnlock();
  }
  release() {
    if (this._semaphore.isLocked()) this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
}
var __awaiter =  false || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {
  return {
    acquire: weight => {
      if (weight !== undefined && weight <= 0) {
        throw new Error(`invalid weight ${weight}: must be positive`);
      }
      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        let isTimeout = false;
        const handle = setTimeout(() => {
          isTimeout = true;
          reject(timeoutError);
        }, timeout);
        try {
          const ticket = yield sync.acquire(weight);
          if (isTimeout) {
            const release = Array.isArray(ticket) ? ticket[1] : ticket;
            release();
          } else {
            clearTimeout(handle);
            resolve(ticket);
          }
        } catch (e) {
          if (!isTimeout) {
            clearTimeout(handle);
            reject(e);
          }
        }
      }));
    },
    runExclusive(callback, weight) {
      return __awaiter(this, void 0, void 0, function* () {
        let release = () => undefined;
        try {
          const ticket = yield this.acquire(weight);
          if (Array.isArray(ticket)) {
            release = ticket[1];
            return yield callback(ticket[0]);
          } else {
            release = ticket;
            return yield callback();
          }
        } finally {
          release();
        }
      });
    },
    release(weight) {
      sync.release(weight);
    },
    cancel() {
      return sync.cancel();
    },
    waitForUnlock: weight => {
      if (weight !== undefined && weight <= 0) {
        throw new Error(`invalid weight ${weight}: must be positive`);
      }
      return new Promise((resolve, reject) => {
        const handle = setTimeout(() => reject(timeoutError), timeout);
        sync.waitForUnlock(weight).then(() => {
          clearTimeout(handle);
          resolve();
        });
      });
    },
    isLocked: () => sync.isLocked(),
    getValue: () => sync.getValue(),
    setValue: value => sync.setValue(value)
  };
}

// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types
function tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return withTimeout(sync, 0, alreadyAcquiredError);
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// the startup function
/******/ 	__webpack_require__.x = () => {
/******/ 		// Load entry module and return exports
/******/ 		// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 		var __webpack_exports__ = __webpack_require__.O(undefined, ["vendors-node_modules_comlink_dist_esm_comlink_mjs-node_modules_babel_runtime_helpers_esm_asyn-8dcd04"], () => (__webpack_require__("./node_modules/@journeyapps/powersync-sdk-web/lib/src/worker/sync/SharedSyncImplementation.worker.js")))
/******/ 		__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 		return __webpack_exports__;
/******/ 	};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks and sibling chunks for the entrypoint
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks and sibling chunks for the entrypoint
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = self.location + "";
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			"vendors-node_modules_journeyapps_powersync-sdk-web_lib_src_worker_sync_SharedSyncImplementati-f231e0": 1
/******/ 		};
/******/ 		
/******/ 		// importScripts chunk loading
/******/ 		var installChunk = (data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			while(chunkIds.length)
/******/ 				installedChunks[chunkIds.pop()] = 1;
/******/ 			parentChunkLoadingFunction(data);
/******/ 		};
/******/ 		__webpack_require__.f.i = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkPowerSync_Angular_Demo"] = self["webpackChunkPowerSync_Angular_Demo"] || [];
/******/ 		var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);
/******/ 		chunkLoadingGlobal.push = installChunk;
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/startup chunk dependencies */
/******/ 	(() => {
/******/ 		var next = __webpack_require__.x;
/******/ 		__webpack_require__.x = () => {
/******/ 			return __webpack_require__.e("vendors-node_modules_comlink_dist_esm_comlink_mjs-node_modules_babel_runtime_helpers_esm_asyn-8dcd04").then(next);
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// run startup
/******/ 	var __webpack_exports__ = __webpack_require__.x();
/******/ 	
/******/ })()
;
//# sourceMappingURL=vendors-node_modules_journeyapps_powersync-sdk-web_lib_src_worker_sync_SharedSyncImplementati-f231e0.js.map